<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neurotome - Neural Anatomy Database Explorer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #e2e8f0;
            overflow-x: hidden;
            min-height: 100vh;
        }

        .header {
            background: rgba(15, 15, 35, 0.95);
            backdrop-filter: blur(20px);
            padding: 1rem 2rem;
            box-shadow: 0 4px 32px rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header h1 {
            color: #f97316;
            font-size: 2rem;
            font-weight: 700;
            text-shadow: 0 0 20px rgba(249, 115, 22, 0.3);
        }

        .container {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            height: calc(100vh - 80px);
            gap: 1rem;
            padding: 1rem;
        }

        .sidebar {
            background: rgba(15, 15, 35, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
        }

        .main-content {
            background: rgba(15, 15, 35, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .details-panel {
            background: rgba(15, 15, 35, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
        }

        .section {
            margin-bottom: 2rem;
        }

        .section h3 {
            color: #f97316;
            margin-bottom: 1rem;
            font-size: 1.2rem;
            border-bottom: 2px solid rgba(249, 115, 22, 0.3);
            padding-bottom: 0.5rem;
            text-shadow: 0 0 10px rgba(249, 115, 22, 0.2);
        }

        .analysis-subsection {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 0.8rem;
            margin-bottom: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .analysis-subsection h4 {
            margin: 0 0 0.8rem 0;
            font-size: 1em;
            font-weight: 600;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.1);
            position: relative;
            padding-right: 20px;
            transition: all 0.3s ease;
        }

        .analysis-subsection h4:after {
            content: '▼';
            position: absolute;
            right: 0;
            font-size: 0.8em;
            transition: transform 0.3s ease;
            color: rgba(255, 255, 255, 0.7);
        }

        .analysis-subsection h4.collapsed:after {
            transform: rotate(-90deg);
        }

        .analysis-subsection h4:hover {
            opacity: 0.8;
            transform: translateY(-1px);
        }

        .label-list, .relationship-list {
            list-style: none;
        }

        .label-item, .relationship-item {
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            margin-bottom: 0.5rem;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 4px solid transparent;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .label-item:hover, .relationship-item:hover {
            background: rgba(107, 114, 128, 0.2);
            border-left-color: #f97316;
            border-color: rgba(249, 115, 22, 0.3);
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(249, 115, 22, 0.2);
        }

        .label-item.active, .relationship-item.active {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            color: white;
            border-left-color: #f97316;
            border-color: rgba(249, 115, 22, 0.5);
            box-shadow: 0 8px 20px rgba(249, 115, 22, 0.3);
        }

        .node-count {
            font-size: 0.85rem;
            color: #94a3b8;
            float: right;
            background: rgba(0, 0, 0, 0.4);
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .active .node-count {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border-color: rgba(255, 255, 255, 0.3);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            display: block;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .sensation-toggles {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .muscle-toggles {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .sensation-toggle {
            padding: 0.6rem;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            cursor: pointer;
            text-align: center;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            user-select: none;
        }

        .sensation-toggle:hover {
            background: rgba(107, 114, 128, 0.2);
            border-color: rgba(249, 115, 22, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(249, 115, 22, 0.2);
        }

        .sensation-toggle.active {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            border-color: #f97316;
            color: white;
            box-shadow: 0 8px 20px rgba(249, 115, 22, 0.3);
        }

        .sensation-toggle.active:hover {
            background: linear-gradient(135deg, #4b5563 0%, #374151 100%);
            transform: translateY(-2px);
        }

        .muscle-toggle {
            padding: 0.6rem;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            cursor: pointer;
            text-align: center;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            user-select: none;
        }

        .muscle-toggle:hover {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.2);
        }

        .muscle-toggle.active {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            border-color: #22c55e;
            color: white;
            box-shadow: 0 8px 20px rgba(34, 197, 94, 0.3);
        }

        .muscle-toggle.active:hover {
            background: linear-gradient(135deg, #047857 0%, #065f46 100%);
            transform: translateY(-2px);
        }

        .sensation-group {
            margin-bottom: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .sensation-group-header {
            background: rgba(0, 0, 0, 0.4);
            padding: 12px 16px;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            color: #e2e8f0;
        }

        .sensation-group-header:hover {
            background: rgba(249, 115, 22, 0.2);
            color: #f97316;
        }

        .sensation-group-header:after {
            content: '▼';
            position: absolute;
            right: 16px;
            transition: transform 0.3s ease;
            font-size: 0.8em;
            color: #f97316;
        }

        .sensation-group-header.collapsed:after {
            transform: rotate(-90deg);
        }

        .sensation-group-content {
            padding: 12px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 8px;
            max-height: 400px;
            overflow-y: auto;
        }

        .sensation-subgroup {
            margin-bottom: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.3);
        }

        .sensation-subgroup-header {
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            font-weight: 500;
            cursor: pointer;
            user-select: none;
            transition: all 0.3s ease;
            position: relative;
            color: #cbd5e1;
            font-size: 0.9em;
        }

        .sensation-subgroup-header:hover {
            background: rgba(249, 115, 22, 0.2);
            color: #f97316;
        }

        .sensation-subgroup-header:after {
            content: '▼';
            position: absolute;
            right: 12px;
            transition: transform 0.3s ease;
            font-size: 0.7em;
            color: #f97316;
        }

        .sensation-subgroup-header.collapsed:after {
            transform: rotate(-90deg);
        }

        .sensation-subgroup-content {
            padding: 6px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .sensation-subgroup .sensation-toggle {
            padding: 4px 8px;
            margin: 0;
            font-size: 0.8em;
            border-radius: 4px;
        }

        .side-columns {
            display: flex;
            gap: 1rem;
            padding: 0.5rem 0;
        }

        .side-column {
            flex: 1;
            min-width: 0; /* Allows content to shrink */
        }

        .column-header {
            color: #f97316;
            font-size: 0.8em;
            font-weight: 600;
            margin: 0 0 0.5rem 0;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid rgba(249, 115, 22, 0.3);
        }

        .side-column .sensation-toggle {
            margin-bottom: 0.25rem;
            font-size: 0.75em;
        }

        .intersection-summary {
            background: rgba(0, 0, 0, 0.4);
            padding: 12px;
            border-radius: 12px;
            margin-bottom: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sensation-list {
            list-style: none;
            padding: 0;
            margin: 8px 0;
        }

        .sensation-list li {
            background: rgba(34, 197, 94, 0.2);
            padding: 4px 8px;
            margin: 2px 0;
            border-radius: 8px;
            font-size: 0.85em;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .intersection-results {
            max-height: 300px;
            overflow-y: auto;
        }

        .node-type-group {
            margin-bottom: 16px;
        }

        .node-type-group h5 {
            color: #f97316;
            font-size: 0.9em;
            margin: 0 0 8px 0;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(249, 115, 22, 0.3);
        }

        .node-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .intersection-node {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 6px 10px;
            margin: 2px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .intersection-node:hover {
            background: rgba(34, 197, 94, 0.2);
            border-color: #22c55e;
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.2);
        }

        .node-name {
            font-size: 0.85em;
            color: #e2e8f0;
        }

        .intersection-actions {
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .intersection-actions .btn {
            width: 100%;
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
            color: white;
            border: 1px solid rgba(34, 197, 94, 0.3);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.2);
        }

        .intersection-actions .btn:hover {
            background: linear-gradient(135deg, #475569 0%, #334155 100%);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
            border-color: rgba(34, 197, 94, 0.5);
        }

        #intersection-status {
            min-height: 1.2em;
        }

        #localize-lesion-btn {
            border: 1px solid rgba(249, 115, 22, 0.5) !important;
            box-shadow: 0 4px 12px rgba(249, 115, 22, 0.3) !important;
            background: linear-gradient(135deg, #FF9800, #4CAF50) !important;
        }

        #localize-lesion-btn:hover:not(:disabled) {
            box-shadow: 0 8px 20px rgba(249, 115, 22, 0.5) !important;
            border-color: rgba(249, 115, 22, 0.7) !important;
            transform: translateY(-1px);
        }

        /* Muscle group styles - similar to sensation groups but with green theme */
        .muscle-group {
            margin-bottom: 12px;
            border: 1px solid rgba(34, 197, 94, 0.2);
            border-radius: 12px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .muscle-group-header {
            background: rgba(0, 0, 0, 0.4);
            padding: 12px 16px;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            border-bottom: 1px solid rgba(34, 197, 94, 0.2);
            transition: all 0.3s ease;
            position: relative;
            color: #e2e8f0;
        }

        .muscle-group-header:hover {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }

        .muscle-group-header:after {
            content: '▼';
            position: absolute;
            right: 16px;
            transition: transform 0.3s ease;
            font-size: 0.8em;
            color: #22c55e;
        }

        .muscle-group-header.collapsed:after {
            transform: rotate(-90deg);
        }

        .muscle-group-content {
            padding: 12px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 8px;
            max-height: 400px;
            overflow-y: auto;
        }

        .muscle-region {
            margin-bottom: 8px;
        }

        .muscle-region-header {
            background: rgba(34, 197, 94, 0.15);
            padding: 8px 12px;
            font-weight: 500;
            cursor: pointer;
            user-select: none;
            border-radius: 4px;
            transition: all 0.3s ease;
            position: relative;
            color: #22c55e;
            margin-left: 16px;
            font-size: 0.9em;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .muscle-region-header:hover {
            background: rgba(34, 197, 94, 0.25);
            color: #16a34a;
        }

        .muscle-region-header:after {
            content: '▼';
            position: absolute;
            right: 12px;
            transition: transform 0.3s ease;
            font-size: 0.7em;
            color: #22c55e;
        }

        .muscle-region-header.collapsed:after {
            transform: rotate(-90deg);
        }

        .muscle-region-content {
            padding: 8px 0 8px 20px;
            border-left: 2px solid rgba(34, 197, 94, 0.2);
            margin-left: 28px;
        }

        .muscle-side-columns {
            display: flex;
            gap: 1rem;
            padding: 0.5rem 0;
        }

        .muscle-side-column {
            flex: 1;
            min-width: 0;
        }

        .muscle-column-header {
            color: #22c55e;
            font-size: 0.8em;
            font-weight: 600;
            margin: 0 0 0.5rem 0;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid rgba(34, 197, 94, 0.3);
        }

        .muscle-side-column .muscle-toggle {
            margin-bottom: 0.25rem;
            font-size: 0.75em;
        }

        #graph-container {
            flex: 1;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            border: 1px solid rgba(249, 115, 22, 0.3);
            box-shadow: 0 4px 12px rgba(249, 115, 22, 0.2);
        }

        .btn:hover {
            background: linear-gradient(135deg, #4b5563 0%, #374151 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(249, 115, 22, 0.4);
            border-color: rgba(249, 115, 22, 0.5);
        }

        .btn.secondary {
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
            border-color: rgba(100, 116, 139, 0.3);
            box-shadow: 0 4px 12px rgba(100, 116, 139, 0.2);
        }

        .btn.secondary:hover {
            background: linear-gradient(135deg, #475569 0%, #334155 100%);
            box-shadow: 0 8px 20px rgba(100, 116, 139, 0.4);
        }

        /* Select dropdown styling */
        select.btn {
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
            border: 1px solid rgba(100, 116, 139, 0.3);
            box-shadow: 0 4px 12px rgba(100, 116, 139, 0.2);
            color: white;
            padding-right: 2rem;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.7rem center;
            background-size: 1em;
        }

        select.btn:hover {
            background: linear-gradient(135deg, #475569 0%, #334155 100%);
            box-shadow: 0 8px 20px rgba(100, 116, 139, 0.4);
        }

        select.btn option {
            background: #0f0f23;
            color: #e2e8f0;
            padding: 0.5rem;
        }

        /* Scrollbar styling for dark theme */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(96, 165, 250, 0.5);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(96, 165, 250, 0.7);
        }

        /* Glow animation for interactive elements */
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px rgba(96, 165, 250, 0.2); }
            50% { box-shadow: 0 0 20px rgba(96, 165, 250, 0.4); }
        }

        .header h1 {
            animation: glow 3s ease-in-out infinite;
        }

        .node-details, .relationship-details {
            background: rgba(0, 0, 0, 0.4);
            padding: 1rem;
            border-radius: 12px;
            margin-bottom: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .property-list {
            list-style: none;
        }

        .property-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .property-key {
            font-weight: 600;
            color: #f97316;
        }

        .property-value {
            color: #cbd5e1;
            word-break: break-word;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #94a3b8;
        }

        .empty-state {
            text-align: center;
            padding: 3rem;
            color: #94a3b8;
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .search-result-item {
            padding: 0.75rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            border-left: 3px solid transparent;
        }

        .search-result-item:hover {
            background-color: rgba(107, 114, 128, 0.2);
            border-left-color: #2196F3;
            transform: translateX(4px);
        }

        .search-result-item.selected {
            background-color: rgba(33, 150, 243, 0.2);
            border-left-color: #2196F3;
            color: #e3f2fd;
        }

        .search-result-labels {
            font-size: 0.8em;
            color: #94a3b8;
            background: rgba(0, 0, 0, 0.4);
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .search-result-name {
            font-weight: 600;
            color: #e2e8f0;
        }

        .search-result-check {
            font-size: 1.2em;
            font-weight: bold;
            min-width: 20px;
            text-align: center;
        }

        #quick-search-input:focus {
            outline: none;
            border-color: #2196F3;
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.2);
            background: rgba(0, 0, 0, 0.5);
        }

        /* D3 Graph Styles */
        .node {
            cursor: grab;
            stroke-width: 2px;
            filter: drop-shadow(0 0 6px rgba(249, 115, 22, 0.3));
        }

        .node:hover {
            cursor: grab;
            stroke-width: 3px;
            filter: drop-shadow(0 0 12px rgba(249, 115, 22, 0.6));
        }

        .node:active {
            cursor: grabbing;
        }

        .link {
            fill: none;
            stroke: #f97316;
            stroke-opacity: 0.6;
            stroke-width: 2px;
            filter: drop-shadow(0 0 3px rgba(249, 115, 22, 0.2));
        }

        .node-label {
            font-size: 11px;
            font-weight: 600;
            text-anchor: middle;
            pointer-events: none;
            fill: white;
            text-shadow: 0 0 8px rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 1);
            user-select: none;
        }

        .link-label {
            font-size: 8px;
            text-anchor: middle;
            pointer-events: none;
            fill: #94a3b8;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
        }

        /* Floating exploration popup */
        .exploration-popup {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 320px;
            max-height: 400px;
            background: rgba(15, 15, 35, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(249, 115, 22, 0.3);
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            overflow-y: auto;
            transform: translateY(100%);
            opacity: 0;
            transition: all 0.3s ease;
        }

        .exploration-popup.visible {
            transform: translateY(0);
            opacity: 1;
        }

        .exploration-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(249, 115, 22, 0.3);
        }

        .exploration-popup-title {
            color: #f97316;
            font-size: 1rem;
            font-weight: 600;
        }

        .exploration-popup-close {
            background: none;
            border: none;
            color: #94a3b8;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .exploration-popup-close:hover {
            background: rgba(249, 115, 22, 0.2);
            color: #f97316;
        }

        .exploration-popup-content {
            font-size: 0.9rem;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
            }

            .exploration-popup {
                bottom: 10px;
                right: 10px;
                width: calc(100vw - 20px);
                max-width: 300px;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 0.5rem;
                gap: 0.5rem;
            }
            
            .header {
                padding: 1rem;
            }
            
            .controls {
                flex-direction: column;
            }

            .exploration-popup {
                bottom: 5px;
                right: 5px;
                width: calc(100vw - 10px);
                max-width: 280px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Neurotome</h1>
    </div>

    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="section">
                <h3>🔍 Quick Search</h3>
                <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                    <input type="text" id="quick-search-input" placeholder="Search anatomical parts..." 
                           style="flex: 1; padding: 0.75rem; border: 2px solid rgba(255, 255, 255, 0.1); border-radius: 12px; font-size: 0.9rem; background: rgba(0, 0, 0, 0.3); color: #e2e8f0;">
                    <button class="btn secondary" id="quick-search-btn" style="background: linear-gradient(135deg, #2196F3, #1976D2); padding: 0.75rem 1rem;">
                        🔍
                    </button>
                </div>
                <div id="quick-search-results" style="max-height: 300px; overflow-y: auto; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; background: rgba(0, 0, 0, 0.3); display: none;">
                    <!-- Search results will appear here -->
                </div>
                <button class="btn" id="add-search-results-btn" style="width: 100%; margin-top: 0.5rem; background: linear-gradient(135deg, #4CAF50, #388E3C); display: none;" disabled>
                    ➕ Add Selected to Visualization
                </button>
            </div>

            <div class="section">
                <h3>🏷️ Node Labels</h3>
                <ul class="label-list" id="label-list">
                    <li class="loading">Loading labels...</li>
                </ul>
            </div>

            <div class="section">
                <h3>🔗 Relationships</h3>
                <div id="relationship-filter-status" style="font-size: 0.8em; color: #94a3b8; margin-bottom: 0.5rem;">
                    Click relationships to filter
                </div>
                <ul class="relationship-list" id="relationship-list">
                    <li class="loading">Loading relationships...</li>
                </ul>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <div class="controls">
                <button class="btn" id="refresh-btn">🔄 Reset & Refresh</button>
                <button class="btn secondary" id="reset-zoom-btn">🎯 Reset Zoom</button>
                <button class="btn secondary" id="toggle-labels-btn">🏷️ Toggle Labels</button>
                <button class="btn secondary" id="clear-filters-btn">🧹 Clear Filters</button>
                <select id="layout-select" class="btn">
                    <option value="force">Force Layout</option>
                    <option value="coordinates">Coordinate Layout</option>
                    <option value="circle">Circle Layout</option>
                    <option value="grid">Grid Layout</option>
                </select>
                <div id="layout-status" style="font-size: 0.8em; color: #666; margin-top: 0.5rem;"></div>
            </div>
            <div id="graph-container">
                <div class="loading" id="graph-loading">
                    <div>Select labels or run localization to see data</div>
                </div>
            </div>
        </div>

        <!-- Details Panel -->
        <div class="details-panel">
            <div class="section">
                <h3>🎯 Localize the Lesion</h3>
                <p style="font-size: 0.9em; color: #666; margin-bottom: 1rem;">
                    Select sensations and muscles to localize potential lesions
                </p>
                
                <!-- Sensation Analysis Subsection -->
                <div class="analysis-subsection">
                    <h4 style="color: #FF9800; margin: 1rem 0 0.5rem 0; cursor: pointer;" onclick="explorer.toggleDropdown(this)">🔸 Sensations</h4>
                    <div class="sensation-toggles" id="sensation-toggles" style="display: none;">
                        <div class="loading">Loading sensations...</div>
                    </div>
                </div>

                <!-- Muscle Analysis Subsection -->
                <div class="analysis-subsection">
                    <h4 style="color: #4CAF50; margin: 1rem 0 0.5rem 0; cursor: pointer;" onclick="explorer.toggleDropdown(this)">🔸 Muscles</h4>
                    <div class="muscle-toggles" id="muscle-toggles" style="display: none;">
                        <div class="loading">Loading muscles...</div>
                    </div>
                </div>

                <!-- Combined Analysis Button -->
                <button class="btn" id="localize-lesion-btn" style="width: 100%; margin-top: 1.5rem; background: linear-gradient(135deg, #FF9800, #4CAF50); color: white; font-weight: bold;" disabled>
                    🎯 Localize the Lesion
                </button>
                <div id="localization-status" style="font-size: 0.8em; color: #666; margin-top: 0.5rem;">Select sensations and/or muscles to analyze</div>
            </div>

            <div class="section" id="node-details-section" style="display: none;">
                <h3>📄 Analysis Results</h3>
                <div id="selected-node-details"></div>
            </div>

            <div class="section" id="relationship-details-section" style="display: none;">
                <h3>🔗 Relationship Details</h3>
                <div id="selected-relationship-details"></div>
            </div>
        </div>
    </div>

    <!-- Floating Exploration Popup -->
    <div id="exploration-popup" class="exploration-popup">
        <div class="exploration-popup-header">
            <div class="exploration-popup-title">🚀 Explore Relationships</div>
            <button class="exploration-popup-close" onclick="explorer.hideExplorationPopup()">&times;</button>
        </div>
        <div id="exploration-popup-content" class="exploration-popup-content">
            <!-- Content will be populated by JavaScript -->
        </div>
    </div>

    <script>
        class Neo4jExplorer {
            constructor() {
                this.selectedLabel = null;
                this.selectedNode = null;
                this.selectedRelationships = new Set(); // Track selected relationships
                this.selectedSensations = new Set(); // Track selected sensations
                this.selectedMuscles = new Set(); // Track selected muscles
                this.selectedSearchResults = new Set(); // Track selected search results
                this.showLabels = true;
                this.simulation = null;
                this.svg = null;
                this.currentLayout = 'force';
                this.explorationPopupShown = false; // Track if popup has been shown this session
                
                this.init();
            }

            // Text formatting helper functions
            formatText(text) {
                if (!text) return '';
                return text.toString()
                    .replace(/_/g, ' ')  // Replace underscores with spaces
                    .replace(/\b\w/g, l => l.toUpperCase());  // Capitalize first letter of each word
            }

            formatRelationshipName(relationshipType) {
                if (!relationshipType) return '';
                return relationshipType
                    .replace(/_/g, ' ')  // Replace underscores with spaces
                    .replace(/\b\w/g, l => l.toUpperCase());  // Capitalize first letter of each word
            }

            async init() {
                try {
                    console.log('Neo4jExplorer: Starting initialization...');
                    
                    console.log('Loading labels...');
                    await this.loadLabels();
                    
                    console.log('Loading relationships...');
                    await this.loadRelationships();
                    
                    console.log('Loading sensations...');
                    await this.loadSensations();
                    
                    console.log('Loading muscles...');
                    await this.loadMuscles();
                    
                    console.log('Initializing graph...');
                    this.initializeGraph();
                    
                    console.log('Setting up event listeners...');
                    this.setupEventListeners();
                    
                    console.log('Setting up quick search...');
                    this.setupQuickSearch();
                    
                    console.log('Neo4jExplorer initialization complete!');
                } catch (error) {
                    console.error('Neo4jExplorer initialization failed:', error);
                    // Show error to user
                    const container = document.querySelector('.container');
                    if (container) {
                        container.innerHTML = `
                            <div style="background: #f8d7da; color: #721c24; padding: 2rem; border-radius: 8px; margin: 2rem;">
                                <h3>Explorer Initialization Failed</h3>
                                <p>Error: ${error.message}</p>
                                <p>Please check the console for more details and refresh the page to try again.</p>
                            </div>
                        `;
                    }
                }
            }

            async loadSensations() {
                try {
                    console.log('Fetching sensations from /api/sensations...');
                    const response = await fetch('/api/sensations');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    const allSensations = await response.json();
                    console.log(`Loaded ${allSensations.length} sensations`);
                    this.renderSensations(allSensations);
                } catch (error) {
                    console.error('Error loading sensations:', error);
                    const sensationToggles = document.getElementById('sensation-toggles');
                    if (sensationToggles) {
                        sensationToggles.innerHTML = '<div class="loading" style="color: red;">Error loading sensations</div>';
                    }
                    throw error;
                }
            }

            renderSensations(sensations) {
                const sensationToggles = document.getElementById('sensation-toggles');
                
                if (sensations.length === 0) {
                    sensationToggles.innerHTML = '<div class="empty-state">No sensations found</div>';
                    return;
                }

                // Filter to get only actual sensations (not motor items)
                const actualSensations = sensations.filter(sensation => {
                    const props = sensation.properties;
                    return !(props.modality === 'motor' || props.type === 'weakness');
                });

                // Group sensations by spinal level and side directly
                const groupedSensations = this.groupSensationsByLevel(actualSensations);
                
                let html = this.renderSpinalLevels(groupedSensations);

                sensationToggles.innerHTML = html;

                // Use event delegation for sensation toggles since they're nested
                sensationToggles.removeEventListener('click', this.sensationClickHandler);
                this.sensationClickHandler = (event) => {
                    if (event.target.classList.contains('sensation-toggle')) {
                        this.toggleSensation(event.target.dataset.sensation);
                    }
                };
                sensationToggles.addEventListener('click', this.sensationClickHandler);
            }

            groupSensationsByLevel(sensations) {
                const grouped = {};
                
                sensations.forEach(sensation => {
                    const props = sensation.properties;
                    
                    // Extract spinal level from name (look for patterns like C5, T1, L2, S1)
                    const spinalLevel = this.extractSpinalLevel(sensation.name);
                    
                    // Extract side (left/right/bilateral)
                    const side = this.extractSide(sensation.name, props);
                    
                    // Initialize nested structure: Spinal Level -> Side -> Individual sensations
                    if (!grouped[spinalLevel]) grouped[spinalLevel] = {};
                    if (!grouped[spinalLevel][side]) grouped[spinalLevel][side] = [];
                    
                    grouped[spinalLevel][side].push(sensation);
                });
                
                return grouped;
            }

            groupSensationsHierarchically(sensations) {
                const grouped = {};
                
                sensations.forEach(sensation => {
                    const props = sensation.properties;
                    
                    // Determine type (Motor vs Sensation)
                    let type = 'Sensation';
                    if (props.modality === 'motor' || props.type === 'weakness') {
                        type = 'Motor';
                    }
                    
                    // Extract spinal level from name (look for patterns like C5, T1, L2, S1)
                    const spinalLevel = this.extractSpinalLevel(sensation.name);
                    
                    // Extract side (left/right/bilateral)
                    const side = this.extractSide(sensation.name, props);
                    
                    // Initialize nested structure
                    if (!grouped[type]) grouped[type] = {};
                    if (!grouped[type][spinalLevel]) grouped[type][spinalLevel] = {};
                    if (!grouped[type][spinalLevel][side]) grouped[type][spinalLevel][side] = [];
                    
                    grouped[type][spinalLevel][side].push(sensation);
                });
                
                return grouped;
            }

            extractSpinalLevel(name) {
                // Look for spinal level patterns: C1-C8, T1-T12, L1-L5, S1-S5
                const spinalMatch = name.match(/\b([CTLS])(\d{1,2})\b/i);
                if (spinalMatch) {
                    return spinalMatch[1].toUpperCase() + spinalMatch[2];
                }
                
                // Look for word patterns like "cervical", "thoracic", "lumbar", "sacral"
                const regionMatch = name.match(/\b(cervical|thoracic|lumbar|sacral)\b/i);
                if (regionMatch) {
                    return regionMatch[1].toLowerCase();
                }
                
                return 'General';
            }

            extractSide(name, props) {
                // Check properties first
                if (props.side) {
                    return props.side === 'left' ? 'Left' : props.side === 'right' ? 'Right' : 'Bilateral';
                }
                
                // Check location property
                if (props.location) {
                    if (props.location.includes('left')) return 'Left';
                    if (props.location.includes('right')) return 'Right';
                }
                
                // Check name for side indicators
                const nameLower = name.toLowerCase();
                if (nameLower.includes('left')) return 'Left';
                if (nameLower.includes('right')) return 'Right';
                if (nameLower.includes('bilateral')) return 'Bilateral';
                
                return 'General';
            }

            countSensationsInGroup(levels) {
                let count = 0;
                Object.values(levels).forEach(sides => {
                    Object.values(sides).forEach(sensations => {
                        count += sensations.length;
                    });
                });
                return count;
            }

            renderSpinalLevels(levels) {
                let html = '';
                
                // Sort spinal levels for better organization
                const sortedLevels = Object.keys(levels).sort(this.sortSpinalLevels.bind(this));
                
                sortedLevels.forEach(level => {
                    const sides = levels[level];
                    const levelCount = this.countSensationsInGroup({[level]: sides});
                    
                    html += `
                        <div class="sensation-subgroup">
                            <div class="sensation-subgroup-header" onclick="explorer.toggleDropdown(this)">
                                ${level} (${levelCount})
                            </div>
                            <div class="sensation-subgroup-content" style="display: none;">
                                ${this.renderSides(sides)}
                            </div>
                        </div>
                    `;
                });
                
                return html;
            }

            renderSides(sides) {
                let html = '';
                
                // Check if we have both Left and Right sides
                const hasLeft = sides['Left'] && sides['Left'].length > 0;
                const hasRight = sides['Right'] && sides['Right'].length > 0;
                
                // If we have both Left and Right, display them as columns directly
                if (hasLeft && hasRight) {
                    const leftSensations = sides['Left'];
                    const rightSensations = sides['Right'];
                    
                    html += `
                        <div class="side-columns">
                            <div class="side-column">
                                <h6 class="column-header">Left (${leftSensations.length})</h6>
                                ${leftSensations.map(sensation => `
                                    <div class="sensation-toggle" data-sensation="${sensation.name}">
                                        ${this.formatText(sensation.name)}
                                    </div>
                                `).join('')}
                            </div>
                            <div class="side-column">
                                <h6 class="column-header">Right (${rightSensations.length})</h6>
                                ${rightSensations.map(sensation => `
                                    <div class="sensation-toggle" data-sensation="${sensation.name}">
                                        ${this.formatText(sensation.name)}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                    
                    // Handle remaining sides (Bilateral, General, etc.) as separate sections
                    Object.keys(sides).forEach(side => {
                        if (side !== 'Left' && side !== 'Right') {
                            const sensations = sides[side];
                            html += `
                                <div class="sensation-subgroup">
                                    <div class="sensation-subgroup-header" onclick="explorer.toggleDropdown(this)">
                                        ${side} (${sensations.length})
                                    </div>
                                    <div class="sensation-subgroup-content" style="display: none;">
                                        ${sensations.map(sensation => `
                                            <div class="sensation-toggle" data-sensation="${sensation.name}">
                                                ${this.formatText(sensation.name)}
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            `;
                        }
                    });
                } else {
                    // Fallback to original layout if we don't have both Left and Right
                    // Sort sides: Left, Right, Bilateral, General
                    const sideOrder = ['Left', 'Right', 'Bilateral', 'General'];
                    const sortedSides = Object.keys(sides).sort((a, b) => {
                        const aIndex = sideOrder.indexOf(a);
                        const bIndex = sideOrder.indexOf(b);
                        return (aIndex === -1 ? 999 : aIndex) - (bIndex === -1 ? 999 : bIndex);
                    });
                    
                    sortedSides.forEach(side => {
                        const sensations = sides[side];
                        
                        html += `
                            <div class="sensation-subgroup">
                                <div class="sensation-subgroup-header" onclick="explorer.toggleDropdown(this)">
                                    ${side} (${sensations.length})
                                </div>
                                <div class="sensation-subgroup-content" style="display: none;">
                                    ${sensations.map(sensation => `
                                        <div class="sensation-toggle" data-sensation="${sensation.name}">
                                            ${this.formatText(sensation.name)}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    });
                }
                
                return html;
            }

            sortSpinalLevels(a, b) {
                // Custom sort for spinal levels: C1-C8, T1-T12, L1-L5, S1-S5, then others
                const order = { 'C': 1, 'T': 2, 'L': 3, 'S': 4 };
                
                const parseLevel = (level) => {
                    const match = level.match(/^([CTLS])(\d+)$/);
                    if (match) {
                        return { region: match[1], number: parseInt(match[2]), priority: order[match[1]] || 999 };
                    }
                    return { region: level, number: 0, priority: 999 };
                };
                
                const levelA = parseLevel(a);
                const levelB = parseLevel(b);
                
                if (levelA.priority !== levelB.priority) {
                    return levelA.priority - levelB.priority;
                }
                
                if (levelA.region === levelB.region) {
                    return levelA.number - levelB.number;
                }
                
                return a.localeCompare(b);
            }

            toggleDropdown(headerElement) {
                const content = headerElement.nextElementSibling;
                const isHidden = content.style.display === 'none';
                
                content.style.display = isHidden ? 'block' : 'none';
                headerElement.classList.toggle('collapsed', !isHidden);
            }

            toggleSensation(sensationName) {
                const toggleElement = document.querySelector(`[data-sensation="${sensationName}"]`);
                
                if (this.selectedSensations.has(sensationName)) {
                    // Remove from selection
                    this.selectedSensations.delete(sensationName);
                    toggleElement.classList.remove('active');
                } else {
                    // Add to selection
                    this.selectedSensations.add(sensationName);
                    toggleElement.classList.add('active');
                }
                
                // Update localization button state
                this.updateLocalizationButton();
            }

            updateLocalizationButton() {
                const button = document.getElementById('localize-lesion-btn');
                const status = document.getElementById('localization-status');
                
                const totalSelections = this.selectedSensations.size + this.selectedMuscles.size;
                
                if (totalSelections > 0) {
                    button.disabled = false;
                    button.style.opacity = '1';
                    
                    let statusText = '';
                    if (this.selectedSensations.size > 0 && this.selectedMuscles.size > 0) {
                        statusText = `${this.selectedSensations.size} sensation(s) + ${this.selectedMuscles.size} muscle(s) selected`;
                    } else if (this.selectedSensations.size > 0) {
                        statusText = `${this.selectedSensations.size} sensation(s) selected`;
                    } else {
                        statusText = `${this.selectedMuscles.size} muscle(s) selected`;
                    }
                    
                    status.innerHTML = statusText;
                    status.style.color = '#2d3748';
                } else {
                    button.disabled = true;
                    button.style.opacity = '0.5';
                    status.innerHTML = 'Select sensations and/or muscles to analyze';
                    status.style.color = '#666';
                }
            }

            async findIntersections() {
                if (this.selectedSensations.size === 0) return;
                
                const sensationArray = Array.from(this.selectedSensations);
                const status = document.getElementById('intersection-status');
                
                try {
                    status.innerHTML = '🔍 Finding intersections...';
                    status.style.color = '#2d3748';
                    
                    const response = await fetch('/api/sensations/intersections', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            sensations: sensationArray
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.nodes && data.nodes.length > 0) {
                        // Clear any existing filters to show pure intersection results
                        this.selectedLabel = null;
                        this.selectedRelationships.clear();
                        
                        // Update filter UI to reflect cleared state
                        document.querySelectorAll('.label-item').forEach(item => {
                            item.classList.remove('active');
                        });
                        document.querySelectorAll('.relationship-item').forEach(item => {
                            item.classList.remove('active');
                        });
                        
                        // Render the intersection graph
                        this.renderGraph(data);
                        
                        // Update status with detailed information
                        const nodeTypes = {};
                        data.nodes.forEach(node => {
                            const label = node.labels[0] || 'Unknown';
                            nodeTypes[label] = (nodeTypes[label] || 0) + 1;
                        });
                        
                        const typeBreakdown = Object.entries(nodeTypes)
                            .map(([type, count]) => `${count} ${type}${count > 1 ? 's' : ''}`)
                            .join(', ');
                        
                        status.innerHTML = `✅ Found ${data.nodes.length} intersecting nodes: ${typeBreakdown}`;
                        status.style.color = '#28a745';
                        
                        // Update filter status to show we're displaying intersection results
                        this.updateFilterStatus();
                        
                        // Show intersection details in the sidebar
                        this.showIntersectionDetails(sensationArray, data);
                        
                    } else {
                        status.innerHTML = '❌ No intersections found';
                        status.style.color = '#dc3545';
                    }
                } catch (error) {
                    console.error('Error finding intersections:', error);
                    status.innerHTML = '❌ Error finding intersections';
                    status.style.color = '#dc3545';
                }
            }

            showLocalizationDetails(localizationData, hasSensations, hasMuscles) {
                // Show the node details section
                const nodeDetailsSection = document.getElementById('node-details-section');
                const nodeDetails = document.getElementById('selected-node-details');
                
                nodeDetailsSection.style.display = 'block';
                
                const nodeCount = localizationData.nodes.length;
                const linkCount = localizationData.links.length;
                
                // Group nodes by type for better presentation
                const nodesByType = {};
                localizationData.nodes.forEach(node => {
                    const type = node.labels[0] || 'Unknown';
                    if (!nodesByType[type]) {
                        nodesByType[type] = [];
                    }
                    nodesByType[type].push(node);
                });
                
                let analysisType = '';
                if (hasSensations && hasMuscles) {
                    analysisType = 'Combined Sensation & Muscle Analysis';
                } else if (hasSensations) {
                    analysisType = 'Sensation Analysis';
                } else {
                    analysisType = 'Muscle Analysis';
                }
                
                let detailsHtml = `
                    <div class="localization-summary">
                        <h4>🎯 ${analysisType}</h4>
                        <p><strong>Selected Items:</strong></p>
                        <ul class="selection-list">
                `;
                
                if (hasSensations) {
                    detailsHtml += `<li><strong>Sensations:</strong> ${Array.from(this.selectedSensations).join(', ')}</li>`;
                }
                if (hasMuscles) {
                    detailsHtml += `<li><strong>Muscles:</strong> ${Array.from(this.selectedMuscles).join(', ')}</li>`;
                }
                
                detailsHtml += `
                        </ul>
                        <p><strong>Results:</strong> ${nodeCount} anatomical structures, ${linkCount} connections</p>
                    </div>
                    <div class="localization-results">
                `;
                
                // Display nodes grouped by type
                Object.entries(nodesByType).forEach(([type, nodes]) => {
                    detailsHtml += `
                        <div class="node-type-group">
                            <h5>${type}s (${nodes.length})</h5>
                            <ul class="node-list">
                    `;
                    
                    nodes.forEach(node => {
                        const name = node.name || node.properties.name || `${type} ${node.id}`;
                        detailsHtml += `
                            <li class="localization-node" data-node-id="${node.id}">
                                <span class="node-name">${name}</span>
                            </li>
                        `;
                    });
                    
                    detailsHtml += `
                            </ul>
                        </div>
                    `;
                });
                
                detailsHtml += `
                    </div>
                    <div class="localization-actions">
                        <button class="btn" onclick="explorer.clearLocalizationResults()">
                            🧹 Clear Results
                        </button>
                    </div>
                `;
                
                nodeDetails.innerHTML = detailsHtml;
                
                // Add click listeners to localization nodes for details
                nodeDetails.querySelectorAll('.localization-node').forEach(nodeElement => {
                    nodeElement.addEventListener('click', () => {
                        const nodeId = nodeElement.dataset.nodeId;
                        const node = localizationData.nodes.find(n => n.id === nodeId);
                        if (node) {
                            this.selectNode(node);
                        }
                    });
                });
            }

            clearLocalizationResults() {
                // Clear the localization results and go back to normal view
                this.selectedSensations.clear();
                this.selectedMuscles.clear();
                
                document.querySelectorAll('.sensation-toggle').forEach(toggle => {
                    toggle.classList.remove('active');
                });
                document.querySelectorAll('.muscle-toggle').forEach(toggle => {
                    toggle.classList.remove('active');
                });
                
                // Hide node details section
                document.getElementById('node-details-section').style.display = 'none';
                
                // Update status
                const status = document.getElementById('localization-status');
                status.innerHTML = 'Select sensations and/or muscles to analyze';
                status.style.color = '#666';
                
                // Update button state
                this.updateLocalizationButton();
                
                // Reload default graph view
                this.loadDefaultGraph();
            }

            // Muscle-related methods
            async loadMuscles() {
                try {
                    console.log('Fetching muscles from /api/nodes/muscle...');
                    const response = await fetch('/api/nodes/muscle?limit=200');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    const muscles = await response.json();
                    console.log(`Loaded ${muscles.length} muscles`);
                    this.renderMuscles(muscles);
                } catch (error) {
                    console.error('Error loading muscles:', error);
                    const muscleToggles = document.getElementById('muscle-toggles');
                    if (muscleToggles) {
                        muscleToggles.innerHTML = '<div class="loading" style="color: red;">Error loading muscles</div>';
                    }
                    throw error;
                }
            }

            renderMuscles(muscles) {
                const muscleToggles = document.getElementById('muscle-toggles');
                
                if (muscles.length === 0) {
                    muscleToggles.innerHTML = '<div class="empty-state">No muscles found</div>';
                    return;
                }

                // Group muscles by location (location -> side)
                const groupedMuscles = this.groupMusclesBySide(muscles);
                
                // Define side display names
                const sideNames = {
                    'left': 'Left Side',
                    'right': 'Right Side',
                    'bilateral': 'Bilateral',
                    'general': 'General'
                };
                
                let html = '';

                // Create hierarchical dropdowns: Location -> Side -> Muscles
                Object.entries(groupedMuscles).forEach(([location, sides]) => {
                    const totalMuscles = Object.values(sides).flat().length;
                    
                    html += `
                        <div class="muscle-group">
                            <div class="muscle-group-header" onclick="explorer.toggleDropdown(this)">
                                ${this.formatText(location)} (${totalMuscles})
                            </div>
                            <div class="muscle-group-content" style="display: none;">
                    `;
                    
                    // Sort sides: left, right, bilateral, general
                    const sortedSides = Object.keys(sides).sort((a, b) => {
                        const sideOrder = ['left', 'right', 'bilateral', 'general'];
                        const aIndex = sideOrder.indexOf(a);
                        const bIndex = sideOrder.indexOf(b);
                        return (aIndex === -1 ? 999 : aIndex) - (bIndex === -1 ? 999 : bIndex);
                    });
                    
                    sortedSides.forEach(side => {
                        const sideMuscles = sides[side];
                        html += `
                            <div class="muscle-region">
                                <div class="muscle-region-header" onclick="explorer.toggleDropdown(this)">
                                    ${sideNames[side] || this.formatText(side)} (${sideMuscles.length})
                                </div>
                                <div class="muscle-region-content" style="display: none;">
                                    ${this.renderMuscleList(sideMuscles)}
                                </div>
                            </div>
                        `;
                    });
                    
                    html += `
                            </div>
                        </div>
                    `;
                });

                muscleToggles.innerHTML = html;

                // Use event delegation for muscle toggles
                muscleToggles.removeEventListener('click', this.muscleClickHandler);
                this.muscleClickHandler = (event) => {
                    if (event.target.classList.contains('muscle-toggle')) {
                        this.toggleMuscle(event.target.dataset.muscle);
                    }
                };
                muscleToggles.addEventListener('click', this.muscleClickHandler);
            }

            groupMusclesBySide(muscles) {
                const grouped = {};
                
                muscles.forEach(muscle => {
                    const props = muscle.properties;
                    const name = muscle.properties.name || muscle.id;
                    
                    // Extract detailed location information
                    const locationInfo = this.extractMuscleLocation(props, name);
                    
                    // Create hierarchical structure: Location -> Side -> Individual muscles
                    if (!grouped[locationInfo.region]) {
                        grouped[locationInfo.region] = {};
                    }
                    if (!grouped[locationInfo.region][locationInfo.side]) {
                        grouped[locationInfo.region][locationInfo.side] = [];
                    }
                    
                    grouped[locationInfo.region][locationInfo.side].push(muscle);
                });
                
                // Remove empty groups
                Object.keys(grouped).forEach(region => {
                    Object.keys(grouped[region]).forEach(side => {
                        if (grouped[region][side].length === 0) {
                            delete grouped[region][side];
                        }
                    });
                    if (Object.keys(grouped[region]).length === 0) {
                        delete grouped[region];
                    }
                });
                
                return grouped;
            }

            extractMuscleLocation(props, name) {
                const location = props.location ? props.location.trim() : '';
                const nameLower = name.toLowerCase();
                
                // Determine side from location or name
                let side = 'general';
                const locationLower = location.toLowerCase();
                
                if (locationLower.includes('left') || nameLower.includes('left')) {
                    side = 'left';
                } else if (locationLower.includes('right') || nameLower.includes('right')) {
                    side = 'right';
                } else if (locationLower.includes('bilateral') || locationLower.includes('both') || 
                          nameLower.includes('bilateral') || nameLower.includes('both')) {
                    side = 'bilateral';
                }
                
                // Use the actual location property as the region, with some cleanup
                let region = location || 'general';
                
                // Clean up the region name by removing side indicators
                region = region.replace(/\b(left|right|bilateral|both)\b/gi, '').trim();
                
                // If region is empty after cleanup, use general
                if (!region || region === '') {
                    region = 'general';
                }
                
                return { side, region };
            }

            renderMuscleList(muscles) {
                return muscles.map(muscle => {
                    const name = muscle.properties.name || muscle.id;
                    return `
                        <div class="muscle-toggle" data-muscle="${name}">
                            ${this.formatText(name)}
                        </div>
                    `;
                }).join('');
            }

            toggleMuscle(muscleName) {
                const toggleElement = document.querySelector(`[data-muscle="${muscleName}"]`);
                
                if (this.selectedMuscles.has(muscleName)) {
                    // Remove from selection
                    this.selectedMuscles.delete(muscleName);
                    toggleElement.classList.remove('active');
                } else {
                    // Add to selection
                    this.selectedMuscles.add(muscleName);
                    toggleElement.classList.add('active');
                }
                
                // Update localization button state
                this.updateLocalizationButton();
            }

            async analyzeMuscles() {
                if (this.selectedMuscles.size === 0) return;
                
                const muscleArray = Array.from(this.selectedMuscles);
                const status = document.getElementById('muscle-status');
                
                try {
                    status.innerHTML = '🔍 Analyzing muscles...';
                    status.style.color = '#2d3748';
                    
                    // Use the graph API with muscle filter
                    const response = await fetch('/api/graph?label=muscle&limit=200');
                    const data = await response.json();
                    
                    // Filter to only show selected muscles and their connections
                    const filteredNodes = data.nodes.filter(node => 
                        node.labels.includes('muscle') && 
                        muscleArray.includes(node.properties.name || node.id) ||
                        !node.labels.includes('muscle') // Include non-muscle nodes that connect to muscles
                    );
                    
                    const selectedMuscleIds = new Set(
                        filteredNodes
                            .filter(node => node.labels.includes('muscle') && 
                                   muscleArray.includes(node.properties.name || node.id))
                            .map(node => node.id)
                    );
                    
                    const filteredLinks = data.links.filter(link =>
                        selectedMuscleIds.has(link.source) || selectedMuscleIds.has(link.target)
                    );
                    
                    const filteredData = {
                        nodes: filteredNodes,
                        links: filteredLinks
                    };
                    
                    if (filteredData.nodes.length > 0) {
                        // Clear any existing filters to show pure muscle results
                        this.selectedLabel = null;
                        this.selectedRelationships.clear();
                        
                        // Update filter UI to reflect cleared state
                        document.querySelectorAll('.label-item').forEach(item => {
                            item.classList.remove('active');
                        });
                        document.querySelectorAll('.relationship-item').forEach(item => {
                            item.classList.remove('active');
                        });
                        
                        // Render the muscle analysis graph
                        this.renderGraph(filteredData);
                        
                        status.innerHTML = `✅ Found ${filteredData.nodes.length} connected nodes for selected muscles`;
                        status.style.color = '#059669';
                        
                        // Update filter status
                        this.updateFilterStatus();
                        
                    } else {
                        status.innerHTML = '❌ No connections found for selected muscles';
                        status.style.color = '#dc3545';
                    }
                } catch (error) {
                    console.error('Error analyzing muscles:', error);
                    status.innerHTML = '❌ Error analyzing muscles';
                    status.style.color = '#dc3545';
                }
            }

            async localizeLesion() {
                const hasSensations = this.selectedSensations.size > 0;
                const hasMuscles = this.selectedMuscles.size > 0;
                
                if (!hasSensations && !hasMuscles) return;
                
                const totalSelected = this.selectedSensations.size + this.selectedMuscles.size;
                if (totalSelected < 2) {
                    const status = document.getElementById('localization-status');
                    status.innerHTML = '⚠️ Please select at least 2 items (sensations/muscles) for lesion localization';
                    status.style.color = '#f59e0b';
                    return;
                }
                
                const status = document.getElementById('localization-status');
                
                try {
                    status.innerHTML = '🎯 Localizing lesion using advanced pathfinding...';
                    status.style.color = '#2d3748';
                    
                    // Prepare the data for the new API endpoint
                    const sensationArray = Array.from(this.selectedSensations);
                    const muscleArray = Array.from(this.selectedMuscles);
                    
                    const response = await fetch('/api/localize-lesion', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            sensations: sensationArray,
                            muscles: muscleArray 
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.found && data.nodes.length > 0) {
                        // Clear any existing filters to show pure localization results
                        this.selectedLabel = null;
                        this.selectedRelationships.clear();
                        
                        // Update filter UI to reflect cleared state
                        document.querySelectorAll('.label-item').forEach(item => {
                            item.classList.remove('active');
                        });
                        document.querySelectorAll('.relationship-item').forEach(item => {
                            item.classList.remove('active');
                        });
                        
                        // Render the fresh pathfinding results
                        this.renderGraph(data);
                        
                        // Create detailed status message
                        const nodeTypes = {};
                        data.nodes.forEach(node => {
                            const label = node.labels[0] || 'Unknown';
                            nodeTypes[label] = (nodeTypes[label] || 0) + 1;
                        });
                        
                        const typeBreakdown = Object.entries(nodeTypes)
                            .map(([type, count]) => `${count} ${type}${count > 1 ? 's' : ''}`)
                            .join(', ');
                        
                        let statusMessage = `✅ Lesion localized: ${data.paths.length} pathway(s) found`;
                        if (data.hub) {
                            statusMessage += ` with common hub`;
                        }
                        statusMessage += ` (${data.nodes.length} anatomical structures: ${typeBreakdown})`;
                        
                        if (data.totalLength > 0) {
                            statusMessage += ` - Total pathway length: ${data.totalLength}`;
                        }
                        
                        status.innerHTML = statusMessage;
                        status.style.color = '#059669';
                        
                        // Update filter status
                        this.updateFilterStatus();
                        
                        // Show detailed results
                        this.showPathfindingDetails(data, sensationArray, muscleArray);
                        
                    } else {
                        // Fallback to showing just the selected items
                        const selectedItems = [...sensationArray, ...muscleArray];
                        status.innerHTML = `⚠️ No connecting pathways found. Showing selected items only (${selectedItems.length} items)`;
                        status.style.color = '#f59e0b';
                        
                        // Show just the selected sensations/muscles as individual nodes
                        await this.showSelectedItemsOnly(sensationArray, muscleArray);
                    }
                } catch (error) {
                    console.error('Error localizing lesion:', error);
                    status.innerHTML = `❌ Error during lesion localization: ${error.message}`;
                    status.style.color = '#dc3545';
                }
            }

            showPathfindingDetails(data, sensations, muscles) {
                // This function can be used to display detailed pathfinding results
                // in the details panel if needed in the future
                console.log('Pathfinding results:', {
                    paths: data.paths,
                    hub: data.hub,
                    totalLength: data.totalLength,
                    selectedSensations: sensations,
                    selectedMuscles: muscles
                });
            }

            async showSelectedItemsOnly(sensations, muscles) {
                // Fallback function to show just the selected items when no pathways are found
                try {
                    const allSelected = [...sensations, ...muscles];
                    const nodes = [];
                    const links = [];
                    
                    // Fetch individual nodes for selected items
                    for (const item of allSelected) {
                        try {
                            // Try to find the node by name
                            const response = await fetch(`/api/search?q=${encodeURIComponent(item)}&limit=1`);
                            const searchData = await response.json();
                            
                            if (searchData.nodes && searchData.nodes.length > 0) {
                                const node = searchData.nodes[0];
                                node.color = sensations.includes(item) ? '#FF9800' : '#4CAF50';
                                nodes.push(node);
                            }
                        } catch (error) {
                            console.warn(`Could not find node for: ${item}`);
                        }
                    }
                    
                    if (nodes.length > 0) {
                        this.renderGraph({ nodes, links });
                    }
                } catch (error) {
                    console.error('Error showing selected items:', error);
                }
            }

            async loadDefaultGraph() {
                try {
                    const response = await fetch('/api/graph?limit=50');
                    const data = await response.json();
                    this.renderGraph(data);
                } catch (error) {
                    console.error('Error loading default graph:', error);
                }
            }

            async loadLabels() {
                try {
                    console.log('Fetching labels from /api/labels...');
                    const response = await fetch('/api/labels');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    const labels = await response.json();
                    console.log(`Loaded ${labels.length} labels:`, labels);
                    this.renderLabels(labels);
                } catch (error) {
                    console.error('Error loading labels:', error);
                    const labelList = document.getElementById('label-list');
                    if (labelList) {
                        labelList.innerHTML = '<li class="loading" style="color: red;">Error loading labels</li>';
                    }
                    throw error;
                }
            }

            async renderLabels(labels) {
                const labelList = document.getElementById('label-list');
                
                if (labels.length === 0) {
                    labelList.innerHTML = '<li class="empty-state">No labels found</li>';
                    return;
                }

                const labelItems = await Promise.all(labels.map(async (label) => {
                    try {
                        const countResponse = await fetch(`/api/nodes/${label}/count`);
                        const countData = await countResponse.json();
                        return `
                            <li class="label-item" data-label="${label}">
                                ${this.formatText(label)}
                                <span class="node-count">${countData.count}</span>
                            </li>
                        `;
                    } catch {
                        return `
                            <li class="label-item" data-label="${label}">
                                ${this.formatText(label)}
                                <span class="node-count">?</span>
                            </li>
                        `;
                    }
                }));

                labelList.innerHTML = labelItems.join('');

                // Add click listeners
                labelList.querySelectorAll('.label-item').forEach(item => {
                    item.addEventListener('click', () => {
                        this.selectLabel(item.dataset.label);
                    });
                });
            }

            async loadRelationships() {
                try {
                    console.log('Fetching relationships from /api/relationships...');
                    const response = await fetch('/api/relationships');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    const relationships = await response.json();
                    console.log(`Loaded ${relationships.length} relationships:`, relationships);
                    this.renderRelationships(relationships);
                } catch (error) {
                    console.error('Error loading relationships:', error);
                    const relationshipList = document.getElementById('relationship-list');
                    if (relationshipList) {
                        relationshipList.innerHTML = '<li class="loading" style="color: red;">Error loading relationships</li>';
                    }
                    throw error;
                }
            }

            renderRelationships(relationships) {
                const relationshipList = document.getElementById('relationship-list');
                
                if (relationships.length === 0) {
                    relationshipList.innerHTML = '<li class="empty-state">No relationships found</li>';
                    return;
                }

                relationshipList.innerHTML = relationships.map(rel => `
                    <li class="relationship-item" data-relationship="${rel}">
                        ${this.formatRelationshipName(rel)}
                    </li>
                `).join('');

                // Add click listeners for relationship selection
                relationshipList.querySelectorAll('.relationship-item').forEach(item => {
                    item.addEventListener('click', () => {
                        this.toggleRelationship(item.dataset.relationship);
                    });
                });
            }

            async selectLabel(label) {
                // Update UI
                document.querySelectorAll('.label-item').forEach(item => {
                    item.classList.remove('active');
                });
                document.querySelector(`[data-label="${label}"]`).classList.add('active');
                
                this.selectedLabel = label;
                await this.loadGraphData();
            }

            async toggleRelationship(relationshipType) {
                const relationshipItem = document.querySelector(`[data-relationship="${relationshipType}"]`);
                
                if (this.selectedRelationships.has(relationshipType)) {
                    // Remove from selection
                    this.selectedRelationships.delete(relationshipType);
                    relationshipItem.classList.remove('active');
                } else {
                    // Add to selection
                    this.selectedRelationships.add(relationshipType);
                    relationshipItem.classList.add('active');
                }
                
                // Update status indicator
                this.updateFilterStatus();
                
                // Reload graph data with new filters
                await this.loadGraphData();
            }

            async clearFilters() {
                // Clear selected label
                this.selectedLabel = null;
                document.querySelectorAll('.label-item').forEach(item => {
                    item.classList.remove('active');
                });

                // Clear selected relationships
                this.selectedRelationships.clear();
                document.querySelectorAll('.relationship-item').forEach(item => {
                    item.classList.remove('active');
                });

                // Clear selected sensations
                this.selectedSensations.clear();
                document.querySelectorAll('.sensation-toggle').forEach(toggle => {
                    toggle.classList.remove('active');
                });

                // Clear selected muscles
                this.selectedMuscles.clear();
                document.querySelectorAll('.muscle-toggle').forEach(toggle => {
                    toggle.classList.remove('active');
                });

                // Hide intersection details if showing
                const nodeDetailsSection = document.getElementById('node-details-section');
                if (nodeDetailsSection.style.display === 'block') {
                    nodeDetailsSection.style.display = 'none';
                }

                // Update status indicators
                this.updateFilterStatus();
                this.updateLocalizationButton();

                // Clear localization status
                const localizationStatus = document.getElementById('localization-status');
                localizationStatus.innerHTML = 'Select sensations and/or muscles to analyze';
                localizationStatus.style.color = '#666';

                // Clear the graph instead of loading default data
                if (this.svg) {
                    this.svg.select('g').selectAll('*').remove();
                    
                    // Show a message indicating filters were cleared
                    const width = this.svg.attr('width');
                    const height = this.svg.attr('height');
                    
                    this.svg.select('g').append('text')
                        .attr('x', width / 2)
                        .attr('y', height / 2)
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'middle')
                        .style('font-size', '18px')
                        .style('fill', '#666')
                        .style('font-family', 'Inter, sans-serif')
                        .text('Filters cleared - Select labels or run localization to see data');
                }
            }

            async refreshAndReset() {
                // Clear the entire graph
                if (this.svg) {
                    this.svg.select('g').selectAll('*').remove();
                }

                // Stop any running simulation
                if (this.simulation) {
                    this.simulation.stop();
                    this.simulation = null;
                }

                // Clear all selections and filters
                this.selectedLabel = null;
                this.selectedNode = null;
                this.selectedRelationships.clear();
                this.selectedSensations.clear();
                this.selectedMuscles.clear();

                // Clear all UI selections
                document.querySelectorAll('.label-item').forEach(item => {
                    item.classList.remove('active');
                });
                document.querySelectorAll('.relationship-item').forEach(item => {
                    item.classList.remove('active');
                });
                document.querySelectorAll('.sensation-toggle').forEach(toggle => {
                    toggle.classList.remove('active');
                });
                document.querySelectorAll('.muscle-toggle').forEach(toggle => {
                    toggle.classList.remove('active');
                });

                // Hide all detail sections
                document.getElementById('node-details-section').style.display = 'none';
                document.getElementById('relationship-details-section').style.display = 'none';

                // Reset status indicators
                this.updateFilterStatus();
                this.updateLocalizationButton();

                // Clear localization status
                const localizationStatus = document.getElementById('localization-status');
                localizationStatus.innerHTML = 'Select sensations and/or muscles to analyze';
                localizationStatus.style.color = '#666';

                // Reset layout to force layout
                this.currentLayout = 'force';
                document.getElementById('layout-select').value = 'force';

                // Clear layout status
                document.getElementById('layout-status').innerHTML = '';

                // Reset zoom
                if (this.svg) {
                    this.svg.transition().duration(750).call(
                        d3.zoom().transform,
                        d3.zoomIdentity
                    );
                }

                // Show loading indicator
                document.getElementById('graph-loading').style.display = 'none';
                
                // Show a message indicating the graph has been cleared
                if (this.svg) {
                    const width = this.svg.attr('width');
                    const height = this.svg.attr('height');
                    
                    this.svg.select('g').append('text')
                        .attr('x', width / 2)
                        .attr('y', height / 2)
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'middle')
                        .style('font-size', '18px')
                        .style('fill', '#666')
                        .style('font-family', 'Inter, sans-serif')
                        .text('Graph cleared - Select labels or run localization to see data');
                }

                console.log('Graph completely cleared - all nodes and relationships removed');
            }

            updateFilterStatus() {
                const statusDiv = document.getElementById('relationship-filter-status');
                if (this.selectedRelationships.size > 0) {
                    const selectedRels = Array.from(this.selectedRelationships).join(', ');
                    statusDiv.innerHTML = `🔍 Active filters: ${selectedRels}`;
                    statusDiv.style.color = '#f97316';
                } else {
                    statusDiv.innerHTML = 'Click relationships to filter';
                    statusDiv.style.color = '#666';
                }
            }

            async loadGraphData() {
                document.getElementById('graph-loading').style.display = 'block';
                
                try {
                    // Build URL with filters
                    let url = '/api/graph?limit=100';
                    
                    if (this.selectedLabel) {
                        url += `&label=${this.selectedLabel}`;
                    }
                    
                    if (this.selectedRelationships.size > 0) {
                        const relationshipsParam = Array.from(this.selectedRelationships).join(',');
                        url += `&relationships=${encodeURIComponent(relationshipsParam)}`;
                    }
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    this.renderGraph(data);
                } catch (error) {
                    console.error('Error loading graph data:', error);
                } finally {
                    document.getElementById('graph-loading').style.display = 'none';
                }
            }

            initializeGraph() {
                const container = document.getElementById('graph-container');
                const width = container.clientWidth;
                const height = container.clientHeight;

                // Clear existing SVG
                d3.select('#graph-container svg').remove();

                this.svg = d3.select('#graph-container')
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                // Add zoom behavior
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 10])
                    .on('zoom', (event) => {
                        this.svg.select('g').attr('transform', event.transform);
                    });

                this.svg.call(zoom);

                // Add click handler to hide exploration popup
                this.svg.on('click', (event) => {
                    // Check if click is on background (not on a node)
                    if (event.target === this.svg.node()) {
                        this.hideExplorationPopup();
                    }
                });

                // Create main group
                this.svg.append('g');
            }

            renderGraph(data) {
                if (!data.nodes || data.nodes.length === 0) {
                    return;
                }

                const width = this.svg.attr('width');
                const height = this.svg.attr('height');
                const g = this.svg.select('g');

                // Clear existing elements
                g.selectAll('*').remove();

                // Add arrow marker definitions
                const defs = this.svg.select('defs').empty() ? this.svg.append('defs') : this.svg.select('defs');
                
                // Clear existing markers
                defs.selectAll('marker').remove();
                
                // Create arrow marker
                defs.append('marker')
                    .attr('id', 'arrow')
                    .attr('viewBox', '0 -5 10 10')
                    .attr('refX', 15)  // Position arrow at end of line
                    .attr('refY', 0)
                    .attr('markerWidth', 6)
                    .attr('markerHeight', 6)
                    .attr('orient', 'auto')
                    .append('path')
                    .attr('d', 'M0,-5L10,0L0,5')
                    .attr('fill', '#f97316')
                    .attr('stroke', '#f97316')
                    .attr('stroke-width', 1);

                // Color scale for different node labels
                const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

                // Check if we should use coordinate layout
                const useCoordinates = this.currentLayout === 'coordinates' && this.hasCoordinates(data.nodes);
                
                // Update layout status
                this.updateLayoutStatus(useCoordinates, data.nodes.length);

                // Prepare node positions for coordinate layout
                if (useCoordinates) {
                    this.setupCoordinateLayout(data.nodes, width, height);
                }

                // Create simulation only for force layouts
                if (!useCoordinates) {
                    this.simulation = d3.forceSimulation(data.nodes)
                        .force('link', d3.forceLink(data.links).id(d => d.id).distance(100))
                        .force('charge', d3.forceManyBody().strength(-300))
                        .force('center', d3.forceCenter(width / 2, height / 2))
                        .force('collision', d3.forceCollide().radius(25)); // Prevent node overlap
                        
                    // Respect fixed positions for hierarchical nodes
                    this.simulation.on('tick', () => {
                        data.nodes.forEach(d => {
                            // Keep nodes with fixed positions (fx, fy) in place
                            if (d.fx !== undefined) d.x = d.fx;
                            if (d.fy !== undefined) d.y = d.fy;
                        });
                        
                        link
                            .attr('x1', d => d.source.x)
                            .attr('y1', d => d.source.y)
                            .attr('x2', d => d.target.x)
                            .attr('y2', d => d.target.y);

                        node
                            .attr('cx', d => d.x)
                            .attr('cy', d => d.y);

                        if (this.showLabels) {
                            labels
                                .attr('x', d => this.calculateLabelX(d, data.nodes))
                                .attr('y', d => this.calculateLabelY(d, data.nodes))
                                .attr('text-anchor', d => d._labelAnchor || 'middle');
                        }
                    });
                } else {
                    // For coordinate layout, stop any existing simulation
                    if (this.simulation) {
                        this.simulation.stop();
                    }
                }

                // Create links
                const link = g.selectAll('.link')
                    .data(data.links)
                    .enter().append('line')
                    .attr('class', 'link')
                    .attr('marker-end', d => d.directed ? 'url(#arrow)' : null);

                // Add relationship labels
                const linkLabels = g.selectAll('.link-label')
                    .data(data.links)
                    .enter().append('text')
                    .attr('class', 'link-label')
                    .text(d => this.formatRelationshipName(d.type || 'unknown'))
                    .style('font-size', '8px')
                    .style('fill', '#666')
                    .style('text-anchor', 'middle')
                    .style('pointer-events', 'none')
                    .style('display', this.showLabels ? 'block' : 'none');

                // Create nodes
                const node = g.selectAll('.node')
                    .data(data.nodes)
                    .enter().append('circle')
                    .attr('class', 'node')
                    .attr('r', 8)
                    .attr('fill', d => {
                        // Use color from data if available, otherwise default to gray
                        if (d.color) {
                            return d.color;
                        }
                        // Fallback to gray for nodes without color data
                        return '#999999';
                    })
                    .attr('stroke', '#fff')
                    .call(d3.drag()
                        .on('start', this.dragstarted.bind(this))
                        .on('drag', this.dragged.bind(this))
                        .on('end', this.dragended.bind(this)));

                // Add node labels with multi-line support
                const labels = g.selectAll('.node-label')
                    .data(data.nodes)
                    .enter().append('text')
                    .attr('class', 'node-label')
                    .style('display', this.showLabels ? 'block' : 'none')
                    .each(function(d) {
                        const textElement = d3.select(this);
                        const lines = explorer.splitTextIntoLines(explorer.formatText(d.name));
                        
                        lines.forEach((line, index) => {
                            textElement.append('tspan')
                                .attr('x', 0) // Will be positioned absolutely later
                                .attr('dy', index === 0 ? '-0.1em' : '1.1em') // Adjusted baseline
                                .text(line);
                        });
                    });

                // Node click handler
                node.on('click', (event, d) => {
                    this.selectNode(d);
                });

                // Node double-click handler for hierarchical relationships
                node.on('dblclick', (event, d) => {
                    event.stopPropagation(); // Prevent zoom behavior
                    this.loadAllRelationshipsHierarchical(d);
                });

                if (useCoordinates) {
                    // Position nodes and links immediately using coordinates
                    this.updateCoordinatePositions(link, node, labels, linkLabels);
                } else {
                    // Update positions on simulation tick for force layouts
                    this.simulation.on('tick', () => {
                        // Respect fixed positions for hierarchical nodes
                        data.nodes.forEach(d => {
                            if (d.fx !== undefined) d.x = d.fx;
                            if (d.fy !== undefined) d.y = d.fy;
                        });
                        
                        // Update links with proper positioning to avoid overlap with nodes
                        link
                            .attr('x1', d => {
                                const dx = d.target.x - d.source.x;
                                const dy = d.target.y - d.source.y;
                                const length = Math.sqrt(dx * dx + dy * dy);
                                const nodeRadius = 8;
                                return length > 0 ? d.source.x + (dx * nodeRadius / length) : d.source.x;
                            })
                            .attr('y1', d => {
                                const dx = d.target.x - d.source.x;
                                const dy = d.target.y - d.source.y;
                                const length = Math.sqrt(dx * dx + dy * dy);
                                const nodeRadius = 8;
                                return length > 0 ? d.source.y + (dy * nodeRadius / length) : d.source.y;
                            })
                            .attr('x2', d => {
                                const dx = d.target.x - d.source.x;
                                const dy = d.target.y - d.source.y;
                                const length = Math.sqrt(dx * dx + dy * dy);
                                const nodeRadius = 8;
                                return length > 0 ? d.target.x - (dx * nodeRadius / length) : d.target.x;
                            })
                            .attr('y2', d => {
                                const dx = d.target.x - d.source.x;
                                const dy = d.target.y - d.source.y;
                                const length = Math.sqrt(dx * dx + dy * dy);
                                const nodeRadius = 8;
                                return length > 0 ? d.target.y - (dy * nodeRadius / length) : d.target.y;
                            });

                        // Position relationship labels in the middle of links
                        linkLabels
                            .attr('x', d => (d.source.x + d.target.x) / 2)
                            .attr('y', d => (d.source.y + d.target.y) / 2);

                        node
                            .attr('cx', d => d.x)
                            .attr('cy', d => d.y);

                        labels
                            .attr('x', d => this.calculateLabelX(d, data.nodes))
                            .attr('y', d => this.calculateLabelY(d, data.nodes))
                            .attr('text-anchor', d => d._labelAnchor || 'middle')
                            .selectAll('tspan')
                            .attr('x', function() {
                                return d3.select(this.parentNode).attr('x');
                            });
                    });
                }
            }

            hasCoordinates(nodes) {
                // Check if nodes have coordinate properties
                // Look for common coordinate property names
                const coordinateProps = ['x', 'y', 'X', 'Y', 'coord_x', 'coord_y', 'position_x', 'position_y'];
                
                return nodes.some(node => {
                    const props = node.properties || {};
                    const hasX = coordinateProps.some(prop => props.hasOwnProperty(prop) && 
                        typeof props[prop] === 'number' && !isNaN(props[prop]));
                    const hasY = coordinateProps.some(prop => prop.includes('y') || prop.includes('Y')) && 
                        coordinateProps.some(prop => props.hasOwnProperty(prop) && 
                        typeof props[prop] === 'number' && !isNaN(props[prop]));
                    return hasX && hasY;
                });
            }

            setupCoordinateLayout(nodes, width, height) {
                // Find coordinate properties and scale them to fit the viewport
                const coordinateProps = ['x', 'y', 'X', 'Y', 'coord_x', 'coord_y', 'position_x', 'position_y'];
                
                // Extract coordinate values
                const coordinates = nodes.map(node => {
                    const props = node.properties || {};
                    let x = null, y = null;
                    
                    // Find X coordinate
                    for (let prop of coordinateProps) {
                        if ((prop.includes('x') || prop.includes('X')) && 
                            props.hasOwnProperty(prop) && 
                            typeof props[prop] === 'number' && !isNaN(props[prop])) {
                            x = props[prop];
                            break;
                        }
                    }
                    
                    // Find Y coordinate
                    for (let prop of coordinateProps) {
                        if ((prop.includes('y') || prop.includes('Y')) && 
                            props.hasOwnProperty(prop) && 
                            typeof props[prop] === 'number' && !isNaN(props[prop])) {
                            y = props[prop];
                            break;
                        }
                    }
                    
                    return { x, y };
                }).filter(coord => coord.x !== null && coord.y !== null);

                if (coordinates.length === 0) return;

                // Calculate bounds
                const xExtent = d3.extent(coordinates, d => d.x);
                const yExtent = d3.extent(coordinates, d => d.y);

                // Create scales with padding
                const padding = 50;
                const xScale = d3.scaleLinear()
                    .domain(xExtent)
                    .range([padding, width - padding]);
                
                const yScale = d3.scaleLinear()
                    .domain(yExtent)
                    .range([height - padding, padding]); // Invert Y for SVG coordinate system

                // Apply scaled coordinates to nodes
                nodes.forEach(node => {
                    const props = node.properties || {};
                    let originalX = null, originalY = null;
                    
                    // Find original coordinates
                    for (let prop of coordinateProps) {
                        if ((prop.includes('x') || prop.includes('X')) && 
                            props.hasOwnProperty(prop) && 
                            typeof props[prop] === 'number' && !isNaN(props[prop])) {
                            originalX = props[prop];
                            break;
                        }
                    }
                    
                    for (let prop of coordinateProps) {
                        if ((prop.includes('y') || prop.includes('Y')) && 
                            props.hasOwnProperty(prop) && 
                            typeof props[prop] === 'number' && !isNaN(props[prop])) {
                            originalY = props[prop];
                            break;
                        }
                    }
                    
                    if (originalX !== null && originalY !== null) {
                        node.x = xScale(originalX);
                        node.y = yScale(originalY);
                        node.fx = node.x; // Fix position
                        node.fy = node.y;
                    }
                });
            }

            updateCoordinatePositions(link, node, labels, linkLabels) {
                // Position nodes using their calculated coordinates
                node
                    .attr('cx', d => d.x || 0)
                    .attr('cy', d => d.y || 0);

                labels
                    .attr('x', d => this.calculateLabelX(d, data.nodes))
                    .attr('y', d => this.calculateLabelY(d, data.nodes))
                    .attr('text-anchor', d => d._labelAnchor || 'middle')
                    .selectAll('tspan')
                    .attr('x', function() {
                        return d3.select(this.parentNode).attr('x');
                    });

                // Position links - get the actual data arrays
                const nodeData = node.data();
                const linkData = link.data();

                link
                    .attr('x1', d => {
                        const sourceNode = nodeData.find(n => n.id === d.source);
                        const targetNode = nodeData.find(n => n.id === d.target);
                        if (!sourceNode || !targetNode) return 0;
                        
                        const dx = targetNode.x - sourceNode.x;
                        const dy = targetNode.y - sourceNode.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const nodeRadius = 8;
                        return length > 0 ? sourceNode.x + (dx * nodeRadius / length) : sourceNode.x;
                    })
                    .attr('y1', d => {
                        const sourceNode = nodeData.find(n => n.id === d.source);
                        const targetNode = nodeData.find(n => n.id === d.target);
                        if (!sourceNode || !targetNode) return 0;
                        
                        const dx = targetNode.x - sourceNode.x;
                        const dy = targetNode.y - sourceNode.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const nodeRadius = 8;
                        return length > 0 ? sourceNode.y + (dy * nodeRadius / length) : sourceNode.y;
                    })
                    .attr('x2', d => {
                        const sourceNode = nodeData.find(n => n.id === d.source);
                        const targetNode = nodeData.find(n => n.id === d.target);
                        if (!sourceNode || !targetNode) return 0;
                        
                        const dx = targetNode.x - sourceNode.x;
                        const dy = targetNode.y - sourceNode.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const nodeRadius = 8;
                        return length > 0 ? targetNode.x - (dx * nodeRadius / length) : targetNode.x;
                    })
                    .attr('y2', d => {
                        const sourceNode = nodeData.find(n => n.id === d.source);
                        const targetNode = nodeData.find(n => n.id === d.target);
                        if (!sourceNode || !targetNode) return 0;
                        
                        const dx = targetNode.x - sourceNode.x;
                        const dy = targetNode.y - sourceNode.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const nodeRadius = 8;
                        return length > 0 ? targetNode.y - (dy * nodeRadius / length) : targetNode.y;
                    });

                // Position relationship labels in the middle of links
                if (linkLabels) {
                    linkLabels
                        .attr('x', d => {
                            const sourceNode = nodeData.find(n => n.id === d.source);
                            const targetNode = nodeData.find(n => n.id === d.target);
                            const sourceX = sourceNode ? sourceNode.x : 0;
                            const targetX = targetNode ? targetNode.x : 0;
                            return (sourceX + targetX) / 2;
                        })
                        .attr('y', d => {
                            const sourceNode = nodeData.find(n => n.id === d.source);
                            const targetNode = nodeData.find(n => n.id === d.target);
                            const sourceY = sourceNode ? sourceNode.y : 0;
                            const targetY = targetNode ? targetNode.y : 0;
                            return (sourceY + targetY) / 2;
                        });
                }
            }

            updateLayoutStatus(useCoordinates, nodeCount) {
                const statusDiv = document.getElementById('layout-status');
                if (this.currentLayout === 'coordinates') {
                    if (useCoordinates) {
                        statusDiv.innerHTML = `📍 Using node coordinates for ${nodeCount} nodes`;
                        statusDiv.style.color = '#28a745';
                    } else {
                        statusDiv.innerHTML = '⚠️ No coordinate data found, using force layout';
                        statusDiv.style.color = '#ffc107';
                    }
                } else {
                    statusDiv.innerHTML = '';
                }
            }

            selectNode(node) {
                this.selectedNode = node;
                this.showNodeDetails(node);
                this.loadNodeRelationships(node.id);

                // Highlight selected node
                this.svg.selectAll('.node')
                    .attr('stroke-width', d => d.id === node.id ? 4 : 2)
                    .attr('stroke', d => d.id === node.id ? '#ff6b6b' : '#fff');
                
                // Show exploration instructions
                this.showExplorationInstructions(node);
            }

            showNodeDetails(node) {
                const section = document.getElementById('node-details-section');
                const details = document.getElementById('selected-node-details');
                
                // Only show specific properties: location and sublocation
                const relevantProperties = {};
                if (node.properties.location) {
                    relevantProperties.Location = node.properties.location;
                }
                if (node.properties.sublocation) {
                    relevantProperties.Sublocation = node.properties.sublocation;
                }
                
                details.innerHTML = `
                    <div class="node-details">
                        <h4>${this.formatText(node.name || node.id)}</h4>
                        <p><strong>Type:</strong> ${node.labels.map(label => this.formatText(label)).join(', ')}</p>
                        <h5>Properties:</h5>
                        ${Object.keys(relevantProperties).length > 0 ? `
                            <ul class="property-list">
                                ${Object.entries(relevantProperties).map(([key, value]) => `
                                    <li class="property-item">
                                        <span class="property-key">${key}:</span>
                                        <span class="property-value">${this.formatText(String(value))}</span>
                                    </li>
                                `).join('')}
                            </ul>
                        ` : '<p style="color: #94a3b8; font-style: italic;">No location properties available</p>'}
                    </div>
                `;
                
                section.style.display = 'block';
            }

            async loadNodeRelationships(nodeId) {
                try {
                    // Load upstream and downstream relationships separately using directed queries
                    const [upstreamResponse, downstreamResponse] = await Promise.all([
                        fetch(`/api/node/${nodeId}/upstream`),
                        fetch(`/api/node/${nodeId}/downstream`)
                    ]);
                    
                    const upstreamRelationships = await upstreamResponse.json();
                    const downstreamRelationships = await downstreamResponse.json();
                    
                    // Combine them for the showRelationshipDetails function
                    const allRelationships = [
                        ...upstreamRelationships.map(rel => ({...rel, _direction: 'upstream'})),
                        ...downstreamRelationships.map(rel => ({...rel, _direction: 'downstream'}))
                    ];
                    
                    this.showRelationshipDetails(allRelationships, upstreamRelationships, downstreamRelationships);
                } catch (error) {
                    console.error('Error loading node relationships:', error);
                }
            }

            showRelationshipDetails(allRelationships, upstreamRelationships, downstreamRelationships) {
                const section = document.getElementById('relationship-details-section');
                const details = document.getElementById('selected-relationship-details');
                
                // Get currently visualized relationships
                const currentLinks = this.svg ? this.svg.selectAll('.link').data() : [];
                const visualizedRelationships = new Set();
                
                currentLinks.forEach(link => {
                    const sourceId = link.source.id || link.source;
                    const targetId = link.target.id || link.target;
                    const relKey = `${sourceId}-${targetId}`;
                    const reverseKey = `${targetId}-${sourceId}`;
                    visualizedRelationships.add(relKey);
                    visualizedRelationships.add(reverseKey);
                });
                
                // Filter each direction separately to only unshown relationships
                const unshownUpstream = upstreamRelationships.filter(rel => {
                    const sourceId = rel.source.id;
                    const targetId = rel.target.id;
                    const relKey = `${sourceId}-${targetId}`;
                    const reverseKey = `${targetId}-${sourceId}`;
                    return !visualizedRelationships.has(relKey) && !visualizedRelationships.has(reverseKey);
                });
                
                const unshownDownstream = downstreamRelationships.filter(rel => {
                    const sourceId = rel.source.id;
                    const targetId = rel.target.id;
                    const relKey = `${sourceId}-${targetId}`;
                    const reverseKey = `${targetId}-${sourceId}`;
                    return !visualizedRelationships.has(relKey) && !visualizedRelationships.has(reverseKey);
                });

                const selectedNodeId = this.selectedNode ? this.selectedNode.id : null;
                if (!selectedNodeId) {
                    details.innerHTML = '<p>No node selected for relationship analysis</p>';
                    section.style.display = 'block';
                    return;
                }
                
                if (unshownUpstream.length === 0 && unshownDownstream.length === 0) {
                    details.innerHTML = '<p>All relationships for this node are currently visualized</p>';
                    section.style.display = 'block';
                    return;
                }

                let html = '';

                // Upstream relationships
                if (unshownUpstream.length > 0) {
                    html += `
                        <div style="margin-bottom: 1.5rem;">
                            <h4 style="color: #22c55e; margin-bottom: 0.5rem;">⬆️ Unshown Upstream Relationships</h4>
                            <p style="font-size: 0.9em; color: #94a3b8; margin-bottom: 1rem;">
                                ${unshownUpstream.length} upstream relationship${unshownUpstream.length !== 1 ? 's' : ''} not currently in visualization
                            </p>
                            ${unshownUpstream.map(rel => `
                                <div class="relationship-details" style="
                                    background: rgba(34, 197, 94, 0.1);
                                    border: 1px solid rgba(34, 197, 94, 0.3);
                                    border-radius: 6px;
                                    padding: 0.8rem;
                                    margin-bottom: 0.8rem;
                                ">
                                    <h5 style="color: #22c55e; margin-bottom: 0.5rem;">${this.formatRelationshipName(rel.relationship.type)}</h5>
                                    <p style="margin-bottom: 0.3rem;"><strong>From:</strong> ${this.formatText(rel.source.properties.name || rel.source.id)}</p>
                                    <p style="margin-bottom: 0.3rem;"><strong>To:</strong> ${this.formatText(rel.target.properties.name || rel.target.id)}</p>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                // Downstream relationships
                if (unshownDownstream.length > 0) {
                    html += `
                        <div style="margin-bottom: 1rem;">
                            <h4 style="color: #3b82f6; margin-bottom: 0.5rem;">⬇️ Unshown Downstream Relationships</h4>
                            <p style="font-size: 0.9em; color: #94a3b8; margin-bottom: 1rem;">
                                ${unshownDownstream.length} downstream relationship${unshownDownstream.length !== 1 ? 's' : ''} not currently in visualization
                            </p>
                            ${unshownDownstream.map(rel => `
                                <div class="relationship-details" style="
                                    background: rgba(59, 130, 246, 0.1);
                                    border: 1px solid rgba(59, 130, 246, 0.3);
                                    border-radius: 6px;
                                    padding: 0.8rem;
                                    margin-bottom: 0.8rem;
                                ">
                                    <h5 style="color: #3b82f6; margin-bottom: 0.5rem;">${this.formatRelationshipName(rel.relationship.type)}</h5>
                                    <p style="margin-bottom: 0.3rem;"><strong>From:</strong> ${this.formatText(rel.source.properties.name || rel.source.id)}</p>
                                    <p style="margin-bottom: 0.3rem;"><strong>To:</strong> ${this.formatText(rel.target.properties.name || rel.target.id)}</p>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }



                details.innerHTML = html;
                section.style.display = 'block';
            }

            showExplorationInstructions(node) {
                // Only show once per session
                if (this.explorationPopupShown) {
                    return;
                }
                
                this.explorationPopupShown = true;
                
                const popup = document.getElementById('exploration-popup');
                const content = document.getElementById('exploration-popup-content');
                
                if (!popup || !content) return;
                
                const instructionsHtml = `
                    <div style="margin-bottom: 1rem;">
                        <h6 style="color: #e2e8f0; margin-bottom: 0.8rem; font-size: 0.9rem;">Selected: <span style="color: #f97316;">${this.formatText(node.name || node.id)}</span></h6>
                    </div>
                    <p style="font-size: 0.85em; margin-bottom: 0.8rem; color: #cbd5e1;">Use keyboard shortcuts to reveal connected nodes:</p>
                    <div style="font-family: monospace; font-size: 0.75em; background: rgba(0, 0, 0, 0.4); padding: 0.8rem; border-radius: 6px; margin-bottom: 0.8rem;">
                        <div style="margin-bottom: 0.4rem; color: #22c55e;">• <strong>Cmd/Ctrl + ↑</strong> → Show upstream <em>(above)</em></div>
                        <div style="margin-bottom: 0.4rem; color: #3b82f6;">• <strong>Cmd/Ctrl + ↓</strong> → Show downstream <em>(below)</em></div>
                        <div style="margin-bottom: 0.4rem; color: #8b5cf6;">• <strong>Double-click node</strong> → Show ALL relationships</div>
                        <div style="margin-bottom: 0; color: #f59e0b;">• <strong>Drag node</strong> → Lock position where dropped</div>
                    </div>
                    <p style="font-size: 0.75em; color: #94a3b8; margin: 0; text-align: center; font-style: italic;">This popup will disappear in 5 seconds...</p>
                `;
                
                content.innerHTML = instructionsHtml;
                popup.classList.add('visible');
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    this.hideExplorationPopup();
                }, 5000);
            }

            hideExplorationPopup() {
                const popup = document.getElementById('exploration-popup');
                if (popup) {
                    popup.classList.remove('visible');
                }
            }

            setupEventListeners() {
                // Refresh button - complete reset
                document.getElementById('refresh-btn').addEventListener('click', () => {
                    this.refreshAndReset();
                });

                // Reset zoom button
                document.getElementById('reset-zoom-btn').addEventListener('click', () => {
                    this.svg.transition().duration(750).call(
                        d3.zoom().transform,
                        d3.zoomIdentity
                    );
                });

                // Toggle labels button
                document.getElementById('toggle-labels-btn').addEventListener('click', () => {
                    this.showLabels = !this.showLabels;
                    this.svg.selectAll('.node-label')
                        .style('display', this.showLabels ? 'block' : 'none');
                    this.svg.selectAll('.link-label')
                        .style('display', this.showLabels ? 'block' : 'none');
                });

                // Clear filters button
                document.getElementById('clear-filters-btn').addEventListener('click', () => {
                    this.clearFilters();
                });

                // Layout selector
                document.getElementById('layout-select').addEventListener('change', (e) => {
                    this.currentLayout = e.target.value;
                    this.applyLayout();
                });

                // Localize lesion button (combines sensation and muscle analysis)
                document.getElementById('localize-lesion-btn').addEventListener('click', () => {
                    this.localizeLesion();
                });

                // Keyboard shortcuts for upstream/downstream exploration
                document.addEventListener('keydown', (e) => {
                    this.handleKeyboardShortcuts(e);
                });
            }



            handleKeyboardShortcuts(e) {
                // Only process shortcuts when a node is selected and Command/Ctrl is pressed
                if (!this.selectedNode || !(e.metaKey || e.ctrlKey)) return;

                switch(e.key) {
                    case 'ArrowUp':
                        e.preventDefault();
                        this.exploreUpstream(this.selectedNode);
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        this.exploreDownstream(this.selectedNode);
                        break;
                }
            }

            async exploreUpstream(node) {
                try {
                    console.log(`Exploring upstream from: ${node.name}`);
                    const response = await fetch(`/api/node/${encodeURIComponent(node.id)}/upstream`);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const upstreamData = await response.json();
                    this.addRelationshipsToGraph(upstreamData, 'upstream');
                } catch (error) {
                    console.error('Error exploring upstream:', error);
                    alert('Failed to load upstream relationships. Please try again.');
                }
            }

            async exploreDownstream(node) {
                try {
                    console.log(`Exploring downstream from: ${node.name}`);
                    const response = await fetch(`/api/node/${encodeURIComponent(node.id)}/downstream`);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const downstreamData = await response.json();
                    this.addRelationshipsToGraph(downstreamData, 'downstream');
                } catch (error) {
                    console.error('Error exploring downstream:', error);
                    alert('Failed to load downstream relationships. Please try again.');
                }
            }

            addRelationshipsToGraph(relationshipData, direction) {
                if (!relationshipData || relationshipData.length === 0) {
                    alert(`No ${direction} relationships found for this node.`);
                    return;
                }

                // Get current graph data
                const currentNodes = this.svg ? this.svg.selectAll('.node').data() : [];
                const currentLinks = this.svg ? this.svg.selectAll('.link').data() : [];
                
                // Create maps for quick lookup
                const existingNodes = new Map(currentNodes.map(n => [n.id, n]));
                const existingLinksSet = new Set(currentLinks.map(l => `${l.source.id || l.source}-${l.target.id || l.target}`));
                
                const newNodes = [];
                const newLinks = [];
                
                // Get the selected node's position for hierarchical positioning
                const selectedNodeData = existingNodes.get(this.selectedNode.id);
                const baseX = selectedNodeData ? selectedNodeData.x : 400;
                const baseY = selectedNodeData ? selectedNodeData.y : 300;
                
                // Calculate hierarchical positions
                const verticalSpacing = 120; // Distance between levels
                const horizontalSpacing = 100; // Distance between nodes at same level
                const nodesAtLevel = relationshipData.length;
                const startX = baseX - ((nodesAtLevel - 1) * horizontalSpacing) / 2;
                
                // Process the relationship data
                relationshipData.forEach((rel, index) => {
                    // Calculate positions based on direction
                    const nodeX = startX + (index * horizontalSpacing);
                    const nodeY = direction === 'upstream' ? baseY - verticalSpacing : baseY + verticalSpacing;
                    
                    // Add source node if not exists
                    if (!existingNodes.has(rel.source.id)) {
                        const sourceNode = {
                            id: rel.source.id,
                            labels: rel.source.labels,
                            properties: rel.source.properties,
                            name: rel.source.properties.name || `Node ${rel.source.id}`,
                            color: direction === 'upstream' ? 'lightcoral' : 'lightblue',
                            x: nodeX,
                            y: nodeY,
                            fx: nodeX, // Fix position to maintain hierarchy
                            fy: nodeY
                        };
                        newNodes.push(sourceNode);
                        existingNodes.set(rel.source.id, sourceNode);
                    }
                    
                    // Add target node if not exists
                    if (!existingNodes.has(rel.target.id)) {
                        const targetNode = {
                            id: rel.target.id,
                            labels: rel.target.labels,
                            properties: rel.target.properties,
                            name: rel.target.properties.name || `Node ${rel.target.id}`,
                            color: direction === 'upstream' ? 'lightcoral' : 'lightblue',
                            x: nodeX,
                            y: nodeY,
                            fx: nodeX, // Fix position to maintain hierarchy
                            fy: nodeY
                        };
                        newNodes.push(targetNode);
                        existingNodes.set(rel.target.id, targetNode);
                    }
                    
                    // Add relationship if not exists
                    const linkKey = `${rel.source.id}-${rel.target.id}`;
                    const reverseLinkKey = `${rel.target.id}-${rel.source.id}`;
                    
                    if (!existingLinksSet.has(linkKey) && !existingLinksSet.has(reverseLinkKey)) {
                        newLinks.push({
                            source: rel.source.id,
                            target: rel.target.id,
                            type: rel.relationship.type,
                            properties: rel.relationship.properties,
                            directed: true
                        });
                        existingLinksSet.add(linkKey);
                    }
                });
                
                // Combine all nodes and links
                const allNodes = [...currentNodes, ...newNodes];
                const allLinks = [...currentLinks, ...newLinks];
                
                // Re-render the graph with hierarchical layout
                const graphData = {
                    nodes: allNodes,
                    links: allLinks
                };
                
                this.renderGraph(graphData);
                
                console.log(`Added ${newNodes.length} new nodes and ${newLinks.length} new ${direction} relationships in hierarchical layout`);
                
                // Show hierarchy information
                this.showHierarchyInfo(direction, newNodes.length);
            }

            showHierarchyInfo(direction, nodeCount) {
                // Create temporary notification
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(34, 197, 94, 0.9);
                    color: white;
                    padding: 1rem;
                    border-radius: 8px;
                    font-size: 0.9em;
                    z-index: 1000;
                    border: 1px solid rgba(34, 197, 94, 0.5);
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                `;
                
                const directionIcon = direction === 'upstream' ? '⬆️' : '⬇️';
                const positionText = direction === 'upstream' ? 'above' : 'below';
                
                notification.innerHTML = `
                    <strong>${directionIcon} ${direction.toUpperCase()} EXPLORATION</strong><br>
                    Added ${nodeCount} nodes ${positionText} selected node
                `;
                
                document.body.appendChild(notification);
                
                // Remove notification after 3 seconds
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 3000);
            }

            async loadAllRelationshipsHierarchical(node) {
                try {
                    // Set the selected node
                    this.selectNode(node);
                    
                    // Show loading notification
                    const notification = document.createElement('div');
                    notification.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: rgba(59, 130, 246, 0.9);
                        color: white;
                        padding: 1rem;
                        border-radius: 8px;
                        font-size: 0.9em;
                        z-index: 1000;
                        border: 1px solid rgba(59, 130, 246, 0.5);
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                    `;
                    
                    notification.innerHTML = `
                        <strong>🔄 LOADING ALL RELATIONSHIPS</strong><br>
                        Loading hierarchical view for "${this.formatText(node.name || node.id)}"...
                    `;
                    
                    document.body.appendChild(notification);
                    
                    // Load both upstream and downstream relationships
                    const [upstreamResponse, downstreamResponse] = await Promise.all([
                        fetch(`/api/node/${node.id}/upstream`),
                        fetch(`/api/node/${node.id}/downstream`)
                    ]);
                    
                    const upstreamData = await upstreamResponse.json();
                    const downstreamData = await downstreamResponse.json();
                    
                    // Remove loading notification
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                    
                    // Add relationships in hierarchical order (upstream first, then downstream)
                    let totalAdded = 0;
                    
                    if (upstreamData && upstreamData.length > 0) {
                        this.addRelationshipsToGraph(upstreamData, 'upstream');
                        totalAdded += upstreamData.length;
                    }
                    
                    if (downstreamData && downstreamData.length > 0) {
                        this.addRelationshipsToGraph(downstreamData, 'downstream');
                        totalAdded += downstreamData.length;
                    }
                    
                    // Show completion notification
                    if (totalAdded > 0) {
                        const successNotification = document.createElement('div');
                        successNotification.style.cssText = `
                            position: fixed;
                            top: 20px;
                            right: 20px;
                            background: rgba(34, 197, 94, 0.9);
                            color: white;
                            padding: 1rem;
                            border-radius: 8px;
                            font-size: 0.9em;
                            z-index: 1000;
                            border: 1px solid rgba(34, 197, 94, 0.5);
                            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                        `;
                        
                        const upstreamCount = upstreamData ? upstreamData.length : 0;
                        const downstreamCount = downstreamData ? downstreamData.length : 0;
                        
                        successNotification.innerHTML = `
                            <strong>✅ HIERARCHICAL VIEW COMPLETE</strong><br>
                            Added ${upstreamCount} upstream and ${downstreamCount} downstream relationships<br>
                            <small>Total: ${totalAdded} new relationships</small>
                        `;
                        
                        document.body.appendChild(successNotification);
                        
                        // Remove notification after 4 seconds
                        setTimeout(() => {
                            if (successNotification.parentNode) {
                                successNotification.parentNode.removeChild(successNotification);
                            }
                        }, 4000);
                    } else {
                        // Show no relationships found notification
                        const noRelNotification = document.createElement('div');
                        noRelNotification.style.cssText = `
                            position: fixed;
                            top: 20px;
                            right: 20px;
                            background: rgba(245, 158, 11, 0.9);
                            color: white;
                            padding: 1rem;
                            border-radius: 8px;
                            font-size: 0.9em;
                            z-index: 1000;
                            border: 1px solid rgba(245, 158, 11, 0.5);
                            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                        `;
                        
                        noRelNotification.innerHTML = `
                            <strong>ℹ️ NO RELATIONSHIPS FOUND</strong><br>
                            No upstream or downstream relationships found for this node
                        `;
                        
                        document.body.appendChild(noRelNotification);
                        
                        setTimeout(() => {
                            if (noRelNotification.parentNode) {
                                noRelNotification.parentNode.removeChild(noRelNotification);
                            }
                        }, 3000);
                    }
                    
                } catch (error) {
                    console.error('Error loading hierarchical relationships:', error);
                    
                    // Show error notification
                    const errorNotification = document.createElement('div');
                    errorNotification.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: rgba(239, 68, 68, 0.9);
                        color: white;
                        padding: 1rem;
                        border-radius: 8px;
                        font-size: 0.9em;
                        z-index: 1000;
                        border: 1px solid rgba(239, 68, 68, 0.5);
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                    `;
                    
                    errorNotification.innerHTML = `
                        <strong>❌ ERROR LOADING RELATIONSHIPS</strong><br>
                        Failed to load hierarchical relationships
                    `;
                    
                    document.body.appendChild(errorNotification);
                    
                    setTimeout(() => {
                        if (errorNotification.parentNode) {
                            errorNotification.parentNode.removeChild(errorNotification);
                        }
                    }, 3000);
                }
            }

            setupQuickSearch() {
                const searchInput = document.getElementById('quick-search-input');
                const searchBtn = document.getElementById('quick-search-btn');
                const searchResults = document.getElementById('quick-search-results');
                const addResultsBtn = document.getElementById('add-search-results-btn');

                if (!searchInput || !searchBtn) return;

                // Search on button click or Enter key
                const performSearch = () => {
                    const query = searchInput.value.trim();
                    if (query.length < 2) {
                        searchResults.style.display = 'none';
                        addResultsBtn.style.display = 'none';
                        return;
                    }
                    this.searchNodes(query);
                };

                searchBtn.addEventListener('click', performSearch);
                searchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        performSearch();
                    }
                });

                // Real-time search as user types (with debounce)
                let searchTimeout;
                searchInput.addEventListener('input', () => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        const query = searchInput.value.trim();
                        if (query.length >= 2) {
                            this.searchNodes(query);
                        } else {
                            searchResults.style.display = 'none';
                            addResultsBtn.style.display = 'none';
                        }
                    }, 300);
                });

                // Add selected results to visualization
                addResultsBtn.addEventListener('click', () => {
                    this.addSearchResultsToGraph();
                });
            }

            async searchNodes(query) {
                try {
                    const response = await fetch(`/api/search?q=${encodeURIComponent(query)}&limit=50`);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const results = await response.json();
                    this.displaySearchResults(results);
                } catch (error) {
                    console.error('Search error:', error);
                    document.getElementById('quick-search-results').innerHTML = 
                        '<div style="padding: 1rem; color: #dc3545; text-align: center;">Search failed. Please try again.</div>';
                    document.getElementById('quick-search-results').style.display = 'block';
                }
            }

            displaySearchResults(results) {
                const searchResults = document.getElementById('quick-search-results');
                const addResultsBtn = document.getElementById('add-search-results-btn');

                if (results.length === 0) {
                    searchResults.innerHTML = '<div style="padding: 1rem; text-align: center; color: #94a3b8;">No results found</div>';
                    searchResults.style.display = 'block';
                    addResultsBtn.style.display = 'none';
                    return;
                }

                let html = '';
                results.forEach(node => {
                    const name = node.properties.name || `Node ${node.id}`;
                    const labels = node.labels.join(', ');
                    const isSelected = this.selectedSearchResults.has(node.id);
                    
                    html += `
                        <div class="search-result-item ${isSelected ? 'selected' : ''}" 
                             data-node-id="${node.id}" 
                             onclick="window.explorer.toggleSearchResult('${node.id}', this)">
                            <div>
                                <div class="search-result-name">${this.formatText(name)}</div>
                                <span class="search-result-labels">${labels}</span>
                            </div>
                            <div class="search-result-check" style="color: ${isSelected ? '#2196F3' : '#94a3b8'};">
                                ${isSelected ? '✓' : '+'}
                            </div>
                        </div>
                    `;
                });

                searchResults.innerHTML = html;
                searchResults.style.display = 'block';
                
                // Show/hide add button based on selected results
                if (this.selectedSearchResults.size > 0) {
                    addResultsBtn.style.display = 'block';
                    addResultsBtn.disabled = false;
                    addResultsBtn.textContent = `➕ Add Selected (${this.selectedSearchResults.size}) to Visualization`;
                } else {
                    addResultsBtn.style.display = 'none';
                }
            }

            toggleSearchResult(nodeId, element) {
                if (this.selectedSearchResults.has(nodeId)) {
                    this.selectedSearchResults.delete(nodeId);
                    element.classList.remove('selected');
                    element.querySelector('.search-result-check').textContent = '+';
                    element.querySelector('.search-result-check').style.color = '#94a3b8';
                } else {
                    this.selectedSearchResults.add(nodeId);
                    element.classList.add('selected');
                    element.querySelector('.search-result-check').textContent = '✓';
                    element.querySelector('.search-result-check').style.color = '#2196F3';
                }

                const addResultsBtn = document.getElementById('add-search-results-btn');
                if (this.selectedSearchResults.size > 0) {
                    addResultsBtn.style.display = 'block';
                    addResultsBtn.disabled = false;
                    addResultsBtn.textContent = `➕ Add Selected (${this.selectedSearchResults.size}) to Visualization`;
                } else {
                    addResultsBtn.style.display = 'none';
                }
            }

            async addSearchResultsToGraph() {
                if (this.selectedSearchResults.size === 0) return;

                try {
                    // Get the selected search results and find their data from the last search
                    const searchResultsContainer = document.getElementById('quick-search-results');
                    const selectedItems = searchResultsContainer.querySelectorAll('.search-result-item.selected');
                    
                    const newNodes = [];
                    
                    // Create nodes from the selected search results without fetching relationships
                    selectedItems.forEach(item => {
                        const nodeId = item.getAttribute('data-node-id');
                        const nameElement = item.querySelector('.search-result-name');
                        const labelsElement = item.querySelector('.search-result-labels');
                        
                        if (nodeId && nameElement) {
                            const nodeName = nameElement.textContent.trim();
                            const nodeLabels = labelsElement ? labelsElement.textContent.split(', ') : [];
                            
                            const newNode = {
                                id: nodeId,
                                labels: nodeLabels,
                                properties: { name: nodeName },
                                name: nodeName,
                                color: "lightgreen", // Color for search results
                                x: Math.random() * 800 + 100, // Random position to avoid overlap
                                y: Math.random() * 600 + 100
                            };
                            newNodes.push(newNode);
                        }
                    });

                    // Add nodes to existing graph data instead of replacing it
                    if (newNodes.length > 0) {
                        // Get current graph data
                        const currentNodes = this.svg ? this.svg.selectAll('.node').data() : [];
                        const currentLinks = this.svg ? this.svg.selectAll('.link').data() : [];
                        
                        // Combine with new nodes (avoid duplicates)
                        const existingNodeIds = new Set(currentNodes.map(n => n.id));
                        const uniqueNewNodes = newNodes.filter(n => !existingNodeIds.has(n.id));
                        
                        const allNodes = [...currentNodes, ...uniqueNewNodes];
                        const allLinks = [...currentLinks]; // Keep existing links, don't add new ones
                        
                        const graphData = {
                            nodes: allNodes,
                            links: allLinks
                        };

                        this.renderGraph(graphData);

                        // Clear search selections
                        this.selectedSearchResults.clear();
                        document.getElementById('add-search-results-btn').style.display = 'none';
                        
                        // Update search results display
                        document.querySelectorAll('.search-result-item').forEach(item => {
                            item.classList.remove('selected');
                            const checkElement = item.querySelector('.search-result-check');
                            if (checkElement) {
                                checkElement.textContent = '+';
                                checkElement.style.color = '#94a3b8';
                            }
                        });

                        console.log(`Added ${uniqueNewNodes.length} nodes to visualization`);
                    } else {
                        alert('No valid nodes found to add.');
                    }

                } catch (error) {
                    console.error('Error adding search results to graph:', error);
                    alert('Failed to add search results to visualization. Please try again.');
                }
            }

            renderSearchResults(results) {
                const searchResults = document.getElementById('search-results');
                
                if (results.length === 0) {
                    searchResults.innerHTML = '<p style="color: #999; padding: 0.5rem;">No results found</p>';
                    return;
                }

                searchResults.innerHTML = results.map(node => `
                    <div class="search-result" style="padding: 0.5rem; border: 1px solid #e2e8f0; margin-bottom: 0.5rem; border-radius: 4px; cursor: pointer;" data-node-id="${node.id}">
                        <strong>${this.formatText(node.properties.name || `Node ${node.id}`)}</strong><br>
                        <small style="color: #666;">${node.labels.map(label => this.formatText(label)).join(', ')}</small>
                    </div>
                `).join('');

                // Add click listeners to search results
                searchResults.querySelectorAll('.search-result').forEach(result => {
                    result.addEventListener('click', () => {
                        const nodeId = parseInt(result.dataset.nodeId);
                        // Find and select the node if it's in the current graph
                        const node = this.svg.selectAll('.node').data().find(n => n.id === nodeId);
                        if (node) {
                            this.selectNode(node);
                        }
                    });
                });
            }

            applyLayout() {
                if (this.currentLayout === 'coordinates') {
                    // Reload graph data to apply coordinate layout
                    this.loadGraphData();
                    return;
                }

                if (!this.simulation) return;

                const width = this.svg.attr('width');
                const height = this.svg.attr('height');

                this.simulation.stop();

                switch (this.currentLayout) {
                    case 'circle':
                        this.simulation.force('center', null);
                        break;
                    case 'grid':
                        this.simulation.force('center', null);
                        break;
                    default:
                        this.simulation.force('center', d3.forceCenter(width / 2, height / 2));
                }

                this.simulation.alpha(1).restart();
            }

            splitTextIntoLines(text, maxCharsPerLine = 12) {
                if (!text || text.length <= maxCharsPerLine) {
                    return [text || ''];
                }
                
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';
                
                for (const word of words) {
                    if (currentLine.length + word.length + 1 <= maxCharsPerLine) {
                        currentLine += (currentLine ? ' ' : '') + word;
                    } else {
                        if (currentLine) {
                            lines.push(currentLine);
                            currentLine = word;
                        } else {
                            // Word is longer than max chars, split it
                            lines.push(word.slice(0, maxCharsPerLine));
                            currentLine = word.slice(maxCharsPerLine);
                        }
                    }
                }
                
                if (currentLine) {
                    lines.push(currentLine);
                }
                
                // Limit to 2 lines max
                return lines.slice(0, 2);
            }

            // Dynamic label positioning methods
            calculateLabelX(node, allNodes) {
                const nodeRadius = 8;
                const labelOffset = 20; // Increased for multi-line labels
                
                // Try positions: right, left, above, below
                // Adjust for multi-line text (each line is ~1.1em apart)
                const positions = [
                    { x: node.x + nodeRadius + labelOffset, y: node.y - 5, anchor: 'start' }, // Right, centered on multi-line
                    { x: node.x - nodeRadius - labelOffset, y: node.y - 5, anchor: 'end' }, // Left, centered on multi-line
                    { x: node.x, y: node.y - nodeRadius - labelOffset, anchor: 'middle' }, // Above
                    { x: node.x, y: node.y + nodeRadius + labelOffset + 10, anchor: 'middle' } // Below, accounting for multi-line height
                ];
                
                // Find position with least overlap
                let bestPosition = positions[0];
                let minOverlaps = this.countLabelOverlaps(positions[0], node, allNodes);
                
                for (let i = 1; i < positions.length; i++) {
                    const overlaps = this.countLabelOverlaps(positions[i], node, allNodes);
                    if (overlaps < minOverlaps) {
                        minOverlaps = overlaps;
                        bestPosition = positions[i];
                    }
                }
                
                // Store the text anchor for later use
                node._labelAnchor = bestPosition.anchor;
                return bestPosition.x;
            }

            calculateLabelY(node, allNodes) {
                const nodeRadius = 8;
                const labelOffset = 20; // Increased for multi-line labels
                
                // Try positions: right, left, above, below
                // Adjust for multi-line text (each line is ~1.1em apart)
                const positions = [
                    { x: node.x + nodeRadius + labelOffset, y: node.y - 5, anchor: 'start' }, // Right, centered on multi-line
                    { x: node.x - nodeRadius - labelOffset, y: node.y - 5, anchor: 'end' }, // Left, centered on multi-line
                    { x: node.x, y: node.y - nodeRadius - labelOffset, anchor: 'middle' }, // Above
                    { x: node.x, y: node.y + nodeRadius + labelOffset + 10, anchor: 'middle' } // Below, accounting for multi-line height
                ];
                
                // Find position with least overlap (same logic as X)
                let bestPosition = positions[0];
                let minOverlaps = this.countLabelOverlaps(positions[0], node, allNodes);
                
                for (let i = 1; i < positions.length; i++) {
                    const overlaps = this.countLabelOverlaps(positions[i], node, allNodes);
                    if (overlaps < minOverlaps) {
                        minOverlaps = overlaps;
                        bestPosition = positions[i];
                    }
                }
                
                return bestPosition.y;
            }

            countLabelOverlaps(position, currentNode, allNodes) {
                let overlaps = 0;
                const labelWidth = 60; // Approximate label width
                const labelHeight = 12; // Approximate label height
                
                for (const otherNode of allNodes) {
                    if (otherNode.id === currentNode.id) continue;
                    
                    // Check distance to other nodes
                    const distance = Math.sqrt(
                        Math.pow(position.x - otherNode.x, 2) + 
                        Math.pow(position.y - otherNode.y, 2)
                    );
                    
                    // If too close to another node, count as overlap
                    if (distance < 30) {
                        overlaps++;
                    }
                    
                    // Check if label would overlap with another node's position
                    if (Math.abs(position.x - otherNode.x) < labelWidth/2 && 
                        Math.abs(position.y - otherNode.y) < labelHeight) {
                        overlaps++;
                    }
                }
                
                return overlaps;
            }

            dragstarted(event, d) {
                if (this.simulation && !event.active) {
                    this.simulation.alphaTarget(0.3).restart();
                }
                d.fx = d.x;
                d.fy = d.y;
            }

            dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            dragended(event, d) {
                if (this.simulation && !event.active) {
                    this.simulation.alphaTarget(0);
                }
                // Keep the position fixed when dragged
                d.fx = event.x;
                d.fy = event.y;
            }
        }

        // Initialize the explorer when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing Neo4jExplorer...');
            try {
                // Make explorer globally accessible
                window.explorer = new Neo4jExplorer();
                console.log('Neo4jExplorer created successfully');
            } catch (error) {
                console.error('Failed to create Neo4jExplorer:', error);
                
                // Show error to user
                const container = document.querySelector('.container');
                if (container) {
                    container.innerHTML = `
                        <div style="background: #f8d7da; color: #721c24; padding: 2rem; border-radius: 8px; margin: 2rem;">
                            <h3>Explorer Failed to Start</h3>
                            <p>Error: ${error.message}</p>
                            <p>Please check the console for more details and refresh the page to try again.</p>
                        </div>
                    `;
                }
            }
        });
    </script>
</body>
</html>
