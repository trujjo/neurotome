<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neurotome - Neural Anatomy Database Explorer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #e2e8f0;
            overflow-x: hidden;
            min-height: 100vh;
        }

        .header {
            background: rgba(15, 15, 35, 0.95);
            backdrop-filter: blur(20px);
            padding: 1rem 2rem;
            box-shadow: 0 4px 32px rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header h1 {
            color: #f97316;
            font-size: 2rem;
            font-weight: 700;
            text-shadow: 0 0 20px rgba(249, 115, 22, 0.3);
        }

        .container {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            height: calc(100vh - 80px);
            gap: 1rem;
            padding: 1rem;
        }

        .sidebar {
            background: rgba(15, 15, 35, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
        }

        .main-content {
            background: rgba(15, 15, 35, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .details-panel {
            background: rgba(15, 15, 35, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
        }

        .section {
            margin-bottom: 2rem;
        }

        .section h3 {
            color: #f97316;
            margin-bottom: 1rem;
            font-size: 1.2rem;
            border-bottom: 2px solid rgba(249, 115, 22, 0.3);
            padding-bottom: 0.5rem;
            text-shadow: 0 0 10px rgba(249, 115, 22, 0.2);
        }

        .search-box {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            font-size: 1rem;
            background: rgba(0, 0, 0, 0.3);
            color: #e2e8f0;
            transition: all 0.3s ease;
            margin-bottom: 1rem;
        }

        .search-box:focus {
            outline: none;
            border-color: #f97316;
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.2);
            background: rgba(0, 0, 0, 0.5);
        }

        .search-box::placeholder {
            color: #94a3b8;
        }

        .label-list, .relationship-list {
            list-style: none;
        }

        .label-item, .relationship-item {
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            margin-bottom: 0.5rem;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 4px solid transparent;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .label-item:hover, .relationship-item:hover {
            background: rgba(107, 114, 128, 0.2);
            border-left-color: #f97316;
            border-color: rgba(249, 115, 22, 0.3);
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(249, 115, 22, 0.2);
        }

        .label-item.active, .relationship-item.active {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            color: white;
            border-left-color: #f97316;
            border-color: rgba(249, 115, 22, 0.5);
            box-shadow: 0 8px 20px rgba(249, 115, 22, 0.3);
        }

        .node-count {
            font-size: 0.85rem;
            color: #94a3b8;
            float: right;
            background: rgba(0, 0, 0, 0.4);
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .active .node-count {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border-color: rgba(255, 255, 255, 0.3);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            display: block;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .sensation-toggles {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .sensation-toggle {
            padding: 0.6rem;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            cursor: pointer;
            text-align: center;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            user-select: none;
        }

        .sensation-toggle:hover {
            background: rgba(107, 114, 128, 0.2);
            border-color: rgba(249, 115, 22, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(249, 115, 22, 0.2);
        }

        .sensation-toggle.active {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            border-color: #f97316;
            color: white;
            box-shadow: 0 8px 20px rgba(249, 115, 22, 0.3);
        }

        .sensation-toggle.active:hover {
            background: linear-gradient(135deg, #4b5563 0%, #374151 100%);
            transform: translateY(-2px);
        }

        .sensation-group {
            margin-bottom: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .sensation-group-header {
            background: rgba(0, 0, 0, 0.4);
            padding: 12px 16px;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            color: #e2e8f0;
        }

        .sensation-group-header:hover {
            background: rgba(249, 115, 22, 0.2);
            color: #f97316;
        }

        .sensation-group-header:after {
            content: '▼';
            position: absolute;
            right: 16px;
            transition: transform 0.3s ease;
            font-size: 0.8em;
            color: #f97316;
        }

        .sensation-group-header.collapsed:after {
            transform: rotate(-90deg);
        }

        .sensation-group-content {
            padding: 12px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 8px;
            max-height: 400px;
            overflow-y: auto;
        }

        .sensation-subgroup {
            margin-bottom: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.3);
        }

        .sensation-subgroup-header {
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            font-weight: 500;
            cursor: pointer;
            user-select: none;
            transition: all 0.3s ease;
            position: relative;
            color: #cbd5e1;
            font-size: 0.9em;
        }

        .sensation-subgroup-header:hover {
            background: rgba(249, 115, 22, 0.2);
            color: #f97316;
        }

        .sensation-subgroup-header:after {
            content: '▼';
            position: absolute;
            right: 12px;
            transition: transform 0.3s ease;
            font-size: 0.7em;
            color: #f97316;
        }

        .sensation-subgroup-header.collapsed:after {
            transform: rotate(-90deg);
        }

        .sensation-subgroup-content {
            padding: 6px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .sensation-subgroup .sensation-toggle {
            padding: 4px 8px;
            margin: 0;
            font-size: 0.8em;
            border-radius: 4px;
        }

        .side-columns {
            display: flex;
            gap: 1rem;
            padding: 0.5rem 0;
        }

        .side-column {
            flex: 1;
            min-width: 0; /* Allows content to shrink */
        }

        .column-header {
            color: #f97316;
            font-size: 0.8em;
            font-weight: 600;
            margin: 0 0 0.5rem 0;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid rgba(249, 115, 22, 0.3);
        }

        .side-column .sensation-toggle {
            margin-bottom: 0.25rem;
            font-size: 0.75em;
        }

        .intersection-summary {
            background: rgba(0, 0, 0, 0.4);
            padding: 12px;
            border-radius: 12px;
            margin-bottom: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sensation-list {
            list-style: none;
            padding: 0;
            margin: 8px 0;
        }

        .sensation-list li {
            background: rgba(34, 197, 94, 0.2);
            padding: 4px 8px;
            margin: 2px 0;
            border-radius: 8px;
            font-size: 0.85em;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .intersection-results {
            max-height: 300px;
            overflow-y: auto;
        }

        .node-type-group {
            margin-bottom: 16px;
        }

        .node-type-group h5 {
            color: #f97316;
            font-size: 0.9em;
            margin: 0 0 8px 0;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(249, 115, 22, 0.3);
        }

        .node-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .intersection-node {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 6px 10px;
            margin: 2px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .intersection-node:hover {
            background: rgba(34, 197, 94, 0.2);
            border-color: #22c55e;
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.2);
        }

        .node-name {
            font-size: 0.85em;
            color: #e2e8f0;
        }

        .intersection-actions {
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .intersection-actions .btn {
            width: 100%;
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
            color: white;
            border: 1px solid rgba(34, 197, 94, 0.3);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.2);
        }

        .intersection-actions .btn:hover {
            background: linear-gradient(135deg, #475569 0%, #334155 100%);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
            border-color: rgba(34, 197, 94, 0.5);
        }

        #intersection-status {
            min-height: 1.2em;
        }

        #find-intersections-btn {
            border: 1px solid rgba(34, 197, 94, 0.3) !important;
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.2) !important;
        }

        #find-intersections-btn:hover:not(:disabled) {
            box-shadow: 0 8px 20px rgba(34, 197, 94, 0.4) !important;
            border-color: rgba(34, 197, 94, 0.5) !important;
        }

        #graph-container {
            flex: 1;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            border: 1px solid rgba(249, 115, 22, 0.3);
            box-shadow: 0 4px 12px rgba(249, 115, 22, 0.2);
        }

        .btn:hover {
            background: linear-gradient(135deg, #4b5563 0%, #374151 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(249, 115, 22, 0.4);
            border-color: rgba(249, 115, 22, 0.5);
        }

        .btn.secondary {
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
            border-color: rgba(100, 116, 139, 0.3);
            box-shadow: 0 4px 12px rgba(100, 116, 139, 0.2);
        }

        .btn.secondary:hover {
            background: linear-gradient(135deg, #475569 0%, #334155 100%);
            box-shadow: 0 8px 20px rgba(100, 116, 139, 0.4);
        }

        /* Select dropdown styling */
        select.btn {
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
            border: 1px solid rgba(100, 116, 139, 0.3);
            box-shadow: 0 4px 12px rgba(100, 116, 139, 0.2);
            color: white;
            padding-right: 2rem;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.7rem center;
            background-size: 1em;
        }

        select.btn:hover {
            background: linear-gradient(135deg, #475569 0%, #334155 100%);
            box-shadow: 0 8px 20px rgba(100, 116, 139, 0.4);
        }

        select.btn option {
            background: #0f0f23;
            color: #e2e8f0;
            padding: 0.5rem;
        }

        /* Scrollbar styling for dark theme */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(96, 165, 250, 0.5);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(96, 165, 250, 0.7);
        }

        /* Glow animation for interactive elements */
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px rgba(96, 165, 250, 0.2); }
            50% { box-shadow: 0 0 20px rgba(96, 165, 250, 0.4); }
        }

        .header h1 {
            animation: glow 3s ease-in-out infinite;
        }

        .node-details, .relationship-details {
            background: rgba(0, 0, 0, 0.4);
            padding: 1rem;
            border-radius: 12px;
            margin-bottom: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .property-list {
            list-style: none;
        }

        .property-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .property-key {
            font-weight: 600;
            color: #f97316;
        }

        .property-value {
            color: #cbd5e1;
            word-break: break-word;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #94a3b8;
        }

        .empty-state {
            text-align: center;
            padding: 3rem;
            color: #94a3b8;
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* D3 Graph Styles */
        .node {
            cursor: pointer;
            stroke-width: 2px;
            filter: drop-shadow(0 0 6px rgba(249, 115, 22, 0.3));
        }

        .node:hover {
            stroke-width: 3px;
            filter: drop-shadow(0 0 12px rgba(249, 115, 22, 0.6));
        }

        .link {
            fill: none;
            stroke: #f97316;
            stroke-opacity: 0.6;
            stroke-width: 2px;
            filter: drop-shadow(0 0 3px rgba(249, 115, 22, 0.2));
        }

        .node-label {
            font-size: 10px;
            font-weight: 600;
            text-anchor: middle;
            pointer-events: none;
            fill: #e2e8f0;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.8);
        }

        .link-label {
            font-size: 8px;
            text-anchor: middle;
            pointer-events: none;
            fill: #94a3b8;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 0.5rem;
                gap: 0.5rem;
            }
            
            .header {
                padding: 1rem;
            }
            
            .controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Neurotome</h1>
    </div>

    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="section">
                <h3>🔍 Search</h3>
                <input type="text" class="search-box" id="search-input" placeholder="Search nodes..." />
                <div id="search-results"></div>
            </div>

            <div class="section">
                <h3>🏷️ Node Labels</h3>
                <ul class="label-list" id="label-list">
                    <li class="loading">Loading labels...</li>
                </ul>
            </div>

            <div class="section">
                <h3>🔗 Relationships</h3>
                <div id="relationship-filter-status" style="font-size: 0.8em; color: #94a3b8; margin-bottom: 0.5rem;">
                    Click relationships to filter
                </div>
                <ul class="relationship-list" id="relationship-list">
                    <li class="loading">Loading relationships...</li>
                </ul>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <div class="controls">
                <button class="btn" id="refresh-btn">🔄 Reset & Refresh</button>
                <button class="btn secondary" id="reset-zoom-btn">🎯 Reset Zoom</button>
                <button class="btn secondary" id="toggle-labels-btn">🏷️ Toggle Labels</button>
                <button class="btn secondary" id="clear-filters-btn">🧹 Clear Filters</button>
                <select id="layout-select" class="btn">
                    <option value="force">Force Layout</option>
                    <option value="coordinates">Coordinate Layout</option>
                    <option value="circle">Circle Layout</option>
                    <option value="grid">Grid Layout</option>
                </select>
                <div id="layout-status" style="font-size: 0.8em; color: #666; margin-top: 0.5rem;"></div>
            </div>
            <div id="graph-container">
                <div class="loading" id="graph-loading">
                    <div>Loading graph data...</div>
                </div>
            </div>
        </div>

        <!-- Details Panel -->
        <div class="details-panel">
            <div class="section">
                <h3>� Sensation Analysis</h3>
                <p style="font-size: 0.9em; color: #666; margin-bottom: 1rem;">
                    Select sensations to find their intersections
                </p>
                <div class="sensation-toggles" id="sensation-toggles">
                    <div class="loading">Loading sensations...</div>
                </div>
                <button class="btn" id="find-intersections-btn" style="width: 100%; margin-top: 1rem;" disabled>
                    🔍 Find Intersections
                </button>
                <div id="intersection-status" style="font-size: 0.8em; color: #666; margin-top: 0.5rem;"></div>
            </div>

            <div class="section" id="node-details-section" style="display: none;">
                <h3>📄 Node Details</h3>
                <div id="selected-node-details"></div>
            </div>

            <div class="section" id="relationship-details-section" style="display: none;">
                <h3>🔗 Relationship Details</h3>
                <div id="selected-relationship-details"></div>
            </div>
        </div>
    </div>

    <script>
        class Neo4jExplorer {
            constructor() {
                this.selectedLabel = null;
                this.selectedNode = null;
                this.selectedRelationships = new Set(); // Track selected relationships
                this.selectedSensations = new Set(); // Track selected sensations
                this.showLabels = true;
                this.simulation = null;
                this.svg = null;
                this.currentLayout = 'force';
                
                this.init();
            }

            async init() {
                try {
                    console.log('Neo4jExplorer: Starting initialization...');
                    
                    console.log('Loading labels...');
                    await this.loadLabels();
                    
                    console.log('Loading relationships...');
                    await this.loadRelationships();
                    
                    console.log('Loading sensations...');
                    await this.loadSensations();
                    
                    console.log('Initializing graph...');
                    this.initializeGraph();
                    
                    console.log('Setting up event listeners...');
                    this.setupEventListeners();
                    
                    console.log('Setting up search...');
                    this.setupSearch();
                    
                    console.log('Neo4jExplorer initialization complete!');
                } catch (error) {
                    console.error('Neo4jExplorer initialization failed:', error);
                    // Show error to user
                    const container = document.querySelector('.container');
                    if (container) {
                        container.innerHTML = `
                            <div style="background: #f8d7da; color: #721c24; padding: 2rem; border-radius: 8px; margin: 2rem;">
                                <h3>Explorer Initialization Failed</h3>
                                <p>Error: ${error.message}</p>
                                <p>Please check the console for more details and refresh the page to try again.</p>
                            </div>
                        `;
                    }
                }
            }

            async loadSensations() {
                try {
                    console.log('Fetching sensations from /api/sensations...');
                    const response = await fetch('/api/sensations');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    const allSensations = await response.json();
                    console.log(`Loaded ${allSensations.length} sensations`);
                    this.renderSensations(allSensations);
                } catch (error) {
                    console.error('Error loading sensations:', error);
                    const sensationToggles = document.getElementById('sensation-toggles');
                    if (sensationToggles) {
                        sensationToggles.innerHTML = '<div class="loading" style="color: red;">Error loading sensations</div>';
                    }
                    throw error;
                }
            }

            renderSensations(sensations) {
                const sensationToggles = document.getElementById('sensation-toggles');
                
                if (sensations.length === 0) {
                    sensationToggles.innerHTML = '<div class="empty-state">No sensations found</div>';
                    return;
                }

                // Group sensations hierarchically: Type -> Spinal Level -> Side -> Individual sensations
                const groupedSensations = this.groupSensationsHierarchically(sensations);
                
                let html = '';

                // Create hierarchical dropdowns
                Object.entries(groupedSensations).forEach(([type, levels]) => {
                    const totalCount = this.countSensationsInGroup(levels);
                    
                    html += `
                        <div class="sensation-group">
                            <div class="sensation-group-header" onclick="explorer.toggleDropdown(this)">
                                ${type} (${totalCount})
                            </div>
                            <div class="sensation-group-content" style="display: none;">
                                ${this.renderSpinalLevels(levels)}
                            </div>
                        </div>
                    `;
                });

                sensationToggles.innerHTML = html;

                // Use event delegation for sensation toggles since they're nested
                sensationToggles.removeEventListener('click', this.sensationClickHandler);
                this.sensationClickHandler = (event) => {
                    if (event.target.classList.contains('sensation-toggle')) {
                        this.toggleSensation(event.target.dataset.sensation);
                    }
                };
                sensationToggles.addEventListener('click', this.sensationClickHandler);
            }

            groupSensationsHierarchically(sensations) {
                const grouped = {};
                
                sensations.forEach(sensation => {
                    const props = sensation.properties;
                    
                    // Determine type (Motor vs Sensation)
                    let type = 'Sensation';
                    if (props.modality === 'motor' || props.type === 'weakness') {
                        type = 'Motor';
                    }
                    
                    // Extract spinal level from name (look for patterns like C5, T1, L2, S1)
                    const spinalLevel = this.extractSpinalLevel(sensation.name);
                    
                    // Extract side (left/right/bilateral)
                    const side = this.extractSide(sensation.name, props);
                    
                    // Initialize nested structure
                    if (!grouped[type]) grouped[type] = {};
                    if (!grouped[type][spinalLevel]) grouped[type][spinalLevel] = {};
                    if (!grouped[type][spinalLevel][side]) grouped[type][spinalLevel][side] = [];
                    
                    grouped[type][spinalLevel][side].push(sensation);
                });
                
                return grouped;
            }

            extractSpinalLevel(name) {
                // Look for spinal level patterns: C1-C8, T1-T12, L1-L5, S1-S5
                const spinalMatch = name.match(/\b([CTLS])(\d{1,2})\b/i);
                if (spinalMatch) {
                    return spinalMatch[1].toUpperCase() + spinalMatch[2];
                }
                
                // Look for word patterns like "cervical", "thoracic", "lumbar", "sacral"
                const regionMatch = name.match(/\b(cervical|thoracic|lumbar|sacral)\b/i);
                if (regionMatch) {
                    return regionMatch[1].toLowerCase();
                }
                
                return 'General';
            }

            extractSide(name, props) {
                // Check properties first
                if (props.side) {
                    return props.side === 'left' ? 'Left' : props.side === 'right' ? 'Right' : 'Bilateral';
                }
                
                // Check location property
                if (props.location) {
                    if (props.location.includes('left')) return 'Left';
                    if (props.location.includes('right')) return 'Right';
                }
                
                // Check name for side indicators
                const nameLower = name.toLowerCase();
                if (nameLower.includes('left')) return 'Left';
                if (nameLower.includes('right')) return 'Right';
                if (nameLower.includes('bilateral')) return 'Bilateral';
                
                return 'General';
            }

            countSensationsInGroup(levels) {
                let count = 0;
                Object.values(levels).forEach(sides => {
                    Object.values(sides).forEach(sensations => {
                        count += sensations.length;
                    });
                });
                return count;
            }

            renderSpinalLevels(levels) {
                let html = '';
                
                // Sort spinal levels for better organization
                const sortedLevels = Object.keys(levels).sort(this.sortSpinalLevels.bind(this));
                
                sortedLevels.forEach(level => {
                    const sides = levels[level];
                    const levelCount = this.countSensationsInGroup({[level]: sides});
                    
                    html += `
                        <div class="sensation-subgroup">
                            <div class="sensation-subgroup-header" onclick="explorer.toggleDropdown(this)">
                                ${level} (${levelCount})
                            </div>
                            <div class="sensation-subgroup-content" style="display: none;">
                                ${this.renderSides(sides)}
                            </div>
                        </div>
                    `;
                });
                
                return html;
            }

            renderSides(sides) {
                let html = '';
                
                // Check if we have both Left and Right sides
                const hasLeft = sides['Left'] && sides['Left'].length > 0;
                const hasRight = sides['Right'] && sides['Right'].length > 0;
                
                // If we have both Left and Right, display them as columns directly
                if (hasLeft && hasRight) {
                    const leftSensations = sides['Left'];
                    const rightSensations = sides['Right'];
                    
                    html += `
                        <div class="side-columns">
                            <div class="side-column">
                                <h6 class="column-header">Left (${leftSensations.length})</h6>
                                ${leftSensations.map(sensation => `
                                    <div class="sensation-toggle" data-sensation="${sensation.name}">
                                        ${sensation.name}
                                    </div>
                                `).join('')}
                            </div>
                            <div class="side-column">
                                <h6 class="column-header">Right (${rightSensations.length})</h6>
                                ${rightSensations.map(sensation => `
                                    <div class="sensation-toggle" data-sensation="${sensation.name}">
                                        ${sensation.name}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                    
                    // Handle remaining sides (Bilateral, General, etc.) as separate sections
                    Object.keys(sides).forEach(side => {
                        if (side !== 'Left' && side !== 'Right') {
                            const sensations = sides[side];
                            html += `
                                <div class="sensation-subgroup">
                                    <div class="sensation-subgroup-header" onclick="explorer.toggleDropdown(this)">
                                        ${side} (${sensations.length})
                                    </div>
                                    <div class="sensation-subgroup-content" style="display: none;">
                                        ${sensations.map(sensation => `
                                            <div class="sensation-toggle" data-sensation="${sensation.name}">
                                                ${sensation.name}
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            `;
                        }
                    });
                } else {
                    // Fallback to original layout if we don't have both Left and Right
                    // Sort sides: Left, Right, Bilateral, General
                    const sideOrder = ['Left', 'Right', 'Bilateral', 'General'];
                    const sortedSides = Object.keys(sides).sort((a, b) => {
                        const aIndex = sideOrder.indexOf(a);
                        const bIndex = sideOrder.indexOf(b);
                        return (aIndex === -1 ? 999 : aIndex) - (bIndex === -1 ? 999 : bIndex);
                    });
                    
                    sortedSides.forEach(side => {
                        const sensations = sides[side];
                        
                        html += `
                            <div class="sensation-subgroup">
                                <div class="sensation-subgroup-header" onclick="explorer.toggleDropdown(this)">
                                    ${side} (${sensations.length})
                                </div>
                                <div class="sensation-subgroup-content" style="display: none;">
                                    ${sensations.map(sensation => `
                                        <div class="sensation-toggle" data-sensation="${sensation.name}">
                                            ${sensation.name}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    });
                }
                
                return html;
            }

            sortSpinalLevels(a, b) {
                // Custom sort for spinal levels: C1-C8, T1-T12, L1-L5, S1-S5, then others
                const order = { 'C': 1, 'T': 2, 'L': 3, 'S': 4 };
                
                const parseLevel = (level) => {
                    const match = level.match(/^([CTLS])(\d+)$/);
                    if (match) {
                        return { region: match[1], number: parseInt(match[2]), priority: order[match[1]] || 999 };
                    }
                    return { region: level, number: 0, priority: 999 };
                };
                
                const levelA = parseLevel(a);
                const levelB = parseLevel(b);
                
                if (levelA.priority !== levelB.priority) {
                    return levelA.priority - levelB.priority;
                }
                
                if (levelA.region === levelB.region) {
                    return levelA.number - levelB.number;
                }
                
                return a.localeCompare(b);
            }

            toggleDropdown(headerElement) {
                const content = headerElement.nextElementSibling;
                const isHidden = content.style.display === 'none';
                
                content.style.display = isHidden ? 'block' : 'none';
                headerElement.classList.toggle('collapsed', !isHidden);
            }

            toggleSensation(sensationName) {
                const toggleElement = document.querySelector(`[data-sensation="${sensationName}"]`);
                
                if (this.selectedSensations.has(sensationName)) {
                    // Remove from selection
                    this.selectedSensations.delete(sensationName);
                    toggleElement.classList.remove('active');
                } else {
                    // Add to selection
                    this.selectedSensations.add(sensationName);
                    toggleElement.classList.add('active');
                }
                
                // Update intersection button state
                this.updateIntersectionButton();
            }

            updateIntersectionButton() {
                const button = document.getElementById('find-intersections-btn');
                const status = document.getElementById('intersection-status');
                
                if (this.selectedSensations.size > 0) {
                    button.disabled = false;
                    button.style.opacity = '1';
                    status.innerHTML = `${this.selectedSensations.size} sensation(s) selected`;
                    status.style.color = '#2d3748';
                } else {
                    button.disabled = true;
                    button.style.opacity = '0.5';
                    status.innerHTML = 'Select sensations to find intersections';
                    status.style.color = '#666';
                }
            }

            async findIntersections() {
                if (this.selectedSensations.size === 0) return;
                
                const sensationArray = Array.from(this.selectedSensations);
                const status = document.getElementById('intersection-status');
                
                try {
                    status.innerHTML = '🔍 Finding intersections...';
                    status.style.color = '#2d3748';
                    
                    const response = await fetch('/api/sensations/intersections', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            sensations: sensationArray
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.nodes && data.nodes.length > 0) {
                        // Clear any existing filters to show pure intersection results
                        this.selectedLabel = null;
                        this.selectedRelationships.clear();
                        
                        // Update filter UI to reflect cleared state
                        document.querySelectorAll('.label-item').forEach(item => {
                            item.classList.remove('active');
                        });
                        document.querySelectorAll('.relationship-item').forEach(item => {
                            item.classList.remove('active');
                        });
                        
                        // Render the intersection graph
                        this.renderGraph(data);
                        
                        // Update status with detailed information
                        const nodeTypes = {};
                        data.nodes.forEach(node => {
                            const label = node.labels[0] || 'Unknown';
                            nodeTypes[label] = (nodeTypes[label] || 0) + 1;
                        });
                        
                        const typeBreakdown = Object.entries(nodeTypes)
                            .map(([type, count]) => `${count} ${type}${count > 1 ? 's' : ''}`)
                            .join(', ');
                        
                        status.innerHTML = `✅ Found ${data.nodes.length} intersecting nodes: ${typeBreakdown}`;
                        status.style.color = '#28a745';
                        
                        // Update filter status to show we're displaying intersection results
                        this.updateFilterStatus();
                        
                        // Show intersection details in the sidebar
                        this.showIntersectionDetails(sensationArray, data);
                        
                    } else {
                        status.innerHTML = '❌ No intersections found';
                        status.style.color = '#dc3545';
                    }
                } catch (error) {
                    console.error('Error finding intersections:', error);
                    status.innerHTML = '❌ Error finding intersections';
                    status.style.color = '#dc3545';
                }
            }

            showIntersectionDetails(selectedSensations, intersectionData) {
                // Show the node details section
                const nodeDetailsSection = document.getElementById('node-details-section');
                const nodeDetails = document.getElementById('selected-node-details');
                
                nodeDetailsSection.style.display = 'block';
                
                const nodeCount = intersectionData.nodes.length;
                const linkCount = intersectionData.links.length;
                
                // Group nodes by type for better presentation
                const nodesByType = {};
                intersectionData.nodes.forEach(node => {
                    const type = node.labels[0] || 'Unknown';
                    if (!nodesByType[type]) {
                        nodesByType[type] = [];
                    }
                    nodesByType[type].push(node);
                });
                
                let detailsHtml = `
                    <div class="intersection-summary">
                        <h4>🔗 Intersection Analysis</h4>
                        <p><strong>Selected Sensations:</strong></p>
                        <ul class="sensation-list">
                            ${selectedSensations.map(sensation => `<li>${sensation}</li>`).join('')}
                        </ul>
                        <p><strong>Results:</strong> ${nodeCount} nodes, ${linkCount} relationships</p>
                    </div>
                    <div class="intersection-results">
                `;
                
                // Display nodes grouped by type
                Object.entries(nodesByType).forEach(([type, nodes]) => {
                    detailsHtml += `
                        <div class="node-type-group">
                            <h5>${type}s (${nodes.length})</h5>
                            <ul class="node-list">
                    `;
                    
                    nodes.forEach(node => {
                        const name = node.name || node.properties.name || `${type} ${node.id}`;
                        detailsHtml += `
                            <li class="intersection-node" data-node-id="${node.id}">
                                <span class="node-name">${name}</span>
                            </li>
                        `;
                    });
                    
                    detailsHtml += `
                            </ul>
                        </div>
                    `;
                });
                
                detailsHtml += `
                    </div>
                    <div class="intersection-actions">
                        <button class="btn" onclick="explorer.clearIntersectionResults()">
                            🧹 Clear Results
                        </button>
                    </div>
                `;
                
                nodeDetails.innerHTML = detailsHtml;
                
                // Add click listeners to intersection nodes for details
                nodeDetails.querySelectorAll('.intersection-node').forEach(nodeElement => {
                    nodeElement.addEventListener('click', () => {
                        const nodeId = nodeElement.dataset.nodeId;
                        const node = intersectionData.nodes.find(n => n.id === nodeId);
                        if (node) {
                            this.selectNode(node);
                        }
                    });
                });
            }

            clearIntersectionResults() {
                // Clear the intersection results and go back to normal view
                this.selectedSensations.clear();
                document.querySelectorAll('.sensation-toggle').forEach(toggle => {
                    toggle.classList.remove('active');
                });
                
                // Hide node details section
                document.getElementById('node-details-section').style.display = 'none';
                
                // Update status
                const status = document.getElementById('intersection-status');
                status.innerHTML = 'Select sensations to find intersections';
                status.style.color = '#666';
                
                // Update button state
                this.updateIntersectionButton();
                
                // Reload default graph view
                this.loadDefaultGraph();
            }

            async loadDefaultGraph() {
                try {
                    const response = await fetch('/api/graph?limit=50');
                    const data = await response.json();
                    this.renderGraph(data);
                } catch (error) {
                    console.error('Error loading default graph:', error);
                }
            }

            async loadLabels() {
                try {
                    console.log('Fetching labels from /api/labels...');
                    const response = await fetch('/api/labels');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    const labels = await response.json();
                    console.log(`Loaded ${labels.length} labels:`, labels);
                    this.renderLabels(labels);
                } catch (error) {
                    console.error('Error loading labels:', error);
                    const labelList = document.getElementById('label-list');
                    if (labelList) {
                        labelList.innerHTML = '<li class="loading" style="color: red;">Error loading labels</li>';
                    }
                    throw error;
                }
            }

            async renderLabels(labels) {
                const labelList = document.getElementById('label-list');
                
                if (labels.length === 0) {
                    labelList.innerHTML = '<li class="empty-state">No labels found</li>';
                    return;
                }

                const labelItems = await Promise.all(labels.map(async (label) => {
                    try {
                        const countResponse = await fetch(`/api/nodes/${label}/count`);
                        const countData = await countResponse.json();
                        return `
                            <li class="label-item" data-label="${label}">
                                ${label}
                                <span class="node-count">${countData.count}</span>
                            </li>
                        `;
                    } catch {
                        return `
                            <li class="label-item" data-label="${label}">
                                ${label}
                                <span class="node-count">?</span>
                            </li>
                        `;
                    }
                }));

                labelList.innerHTML = labelItems.join('');

                // Add click listeners
                labelList.querySelectorAll('.label-item').forEach(item => {
                    item.addEventListener('click', () => {
                        this.selectLabel(item.dataset.label);
                    });
                });
            }

            async loadRelationships() {
                try {
                    console.log('Fetching relationships from /api/relationships...');
                    const response = await fetch('/api/relationships');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    const relationships = await response.json();
                    console.log(`Loaded ${relationships.length} relationships:`, relationships);
                    this.renderRelationships(relationships);
                } catch (error) {
                    console.error('Error loading relationships:', error);
                    const relationshipList = document.getElementById('relationship-list');
                    if (relationshipList) {
                        relationshipList.innerHTML = '<li class="loading" style="color: red;">Error loading relationships</li>';
                    }
                    throw error;
                }
            }

            renderRelationships(relationships) {
                const relationshipList = document.getElementById('relationship-list');
                
                if (relationships.length === 0) {
                    relationshipList.innerHTML = '<li class="empty-state">No relationships found</li>';
                    return;
                }

                relationshipList.innerHTML = relationships.map(rel => `
                    <li class="relationship-item" data-relationship="${rel}">
                        ${rel}
                    </li>
                `).join('');

                // Add click listeners for relationship selection
                relationshipList.querySelectorAll('.relationship-item').forEach(item => {
                    item.addEventListener('click', () => {
                        this.toggleRelationship(item.dataset.relationship);
                    });
                });
            }

            async selectLabel(label) {
                // Update UI
                document.querySelectorAll('.label-item').forEach(item => {
                    item.classList.remove('active');
                });
                document.querySelector(`[data-label="${label}"]`).classList.add('active');
                
                this.selectedLabel = label;
                await this.loadGraphData();
            }

            async toggleRelationship(relationshipType) {
                const relationshipItem = document.querySelector(`[data-relationship="${relationshipType}"]`);
                
                if (this.selectedRelationships.has(relationshipType)) {
                    // Remove from selection
                    this.selectedRelationships.delete(relationshipType);
                    relationshipItem.classList.remove('active');
                } else {
                    // Add to selection
                    this.selectedRelationships.add(relationshipType);
                    relationshipItem.classList.add('active');
                }
                
                // Update status indicator
                this.updateFilterStatus();
                
                // Reload graph data with new filters
                await this.loadGraphData();
            }

            async clearFilters() {
                // Clear selected label
                this.selectedLabel = null;
                document.querySelectorAll('.label-item').forEach(item => {
                    item.classList.remove('active');
                });

                // Clear selected relationships
                this.selectedRelationships.clear();
                document.querySelectorAll('.relationship-item').forEach(item => {
                    item.classList.remove('active');
                });

                // Clear selected sensations
                this.selectedSensations.clear();
                document.querySelectorAll('.sensation-toggle').forEach(toggle => {
                    toggle.classList.remove('active');
                });

                // Hide intersection details if showing
                const nodeDetailsSection = document.getElementById('node-details-section');
                if (nodeDetailsSection.style.display === 'block') {
                    nodeDetailsSection.style.display = 'none';
                }

                // Update status indicators
                this.updateFilterStatus();
                this.updateIntersectionButton();

                // Clear intersection status
                const intersectionStatus = document.getElementById('intersection-status');
                intersectionStatus.innerHTML = 'Select sensations to find intersections';
                intersectionStatus.style.color = '#666';

                // Reload graph data without filters
                await this.loadGraphData();
            }

            async refreshAndReset() {
                // Clear the entire graph
                if (this.svg) {
                    this.svg.select('g').selectAll('*').remove();
                }

                // Stop any running simulation
                if (this.simulation) {
                    this.simulation.stop();
                    this.simulation = null;
                }

                // Clear all selections and filters
                this.selectedLabel = null;
                this.selectedNode = null;
                this.selectedRelationships.clear();
                this.selectedSensations.clear();

                // Clear all UI selections
                document.querySelectorAll('.label-item').forEach(item => {
                    item.classList.remove('active');
                });
                document.querySelectorAll('.relationship-item').forEach(item => {
                    item.classList.remove('active');
                });
                document.querySelectorAll('.sensation-toggle').forEach(toggle => {
                    toggle.classList.remove('active');
                });

                // Hide all detail sections
                document.getElementById('node-details-section').style.display = 'none';
                document.getElementById('relationship-details-section').style.display = 'none';

                // Reset status indicators
                this.updateFilterStatus();
                this.updateIntersectionButton();

                // Clear intersection status
                const intersectionStatus = document.getElementById('intersection-status');
                intersectionStatus.innerHTML = 'Select sensations to find intersections';
                intersectionStatus.style.color = '#666';

                // Reset layout to force layout
                this.currentLayout = 'force';
                document.getElementById('layout-select').value = 'force';

                // Clear layout status
                document.getElementById('layout-status').innerHTML = '';

                // Reset zoom
                if (this.svg) {
                    this.svg.transition().duration(750).call(
                        d3.zoom().transform,
                        d3.zoomIdentity
                    );
                }

                // Show loading indicator
                document.getElementById('graph-loading').style.display = 'block';

                // Load fresh default graph data
                try {
                    const response = await fetch('/api/graph?limit=50');
                    const data = await response.json();
                    this.renderGraph(data);
                } catch (error) {
                    console.error('Error loading fresh graph data:', error);
                } finally {
                    document.getElementById('graph-loading').style.display = 'none';
                }
            }

            updateFilterStatus() {
                const statusDiv = document.getElementById('relationship-filter-status');
                if (this.selectedRelationships.size > 0) {
                    const selectedRels = Array.from(this.selectedRelationships).join(', ');
                    statusDiv.innerHTML = `🔍 Active filters: ${selectedRels}`;
                    statusDiv.style.color = '#f97316';
                } else {
                    statusDiv.innerHTML = 'Click relationships to filter';
                    statusDiv.style.color = '#666';
                }
            }

            async loadGraphData() {
                document.getElementById('graph-loading').style.display = 'block';
                
                try {
                    // Build URL with filters
                    let url = '/api/graph?limit=100';
                    
                    if (this.selectedLabel) {
                        url += `&label=${this.selectedLabel}`;
                    }
                    
                    if (this.selectedRelationships.size > 0) {
                        const relationshipsParam = Array.from(this.selectedRelationships).join(',');
                        url += `&relationships=${encodeURIComponent(relationshipsParam)}`;
                    }
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    this.renderGraph(data);
                } catch (error) {
                    console.error('Error loading graph data:', error);
                } finally {
                    document.getElementById('graph-loading').style.display = 'none';
                }
            }

            initializeGraph() {
                const container = document.getElementById('graph-container');
                const width = container.clientWidth;
                const height = container.clientHeight;

                // Clear existing SVG
                d3.select('#graph-container svg').remove();

                this.svg = d3.select('#graph-container')
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                // Add zoom behavior
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 10])
                    .on('zoom', (event) => {
                        this.svg.select('g').attr('transform', event.transform);
                    });

                this.svg.call(zoom);

                // Create main group
                this.svg.append('g');
            }

            renderGraph(data) {
                if (!data.nodes || data.nodes.length === 0) {
                    return;
                }

                const width = this.svg.attr('width');
                const height = this.svg.attr('height');
                const g = this.svg.select('g');

                // Clear existing elements
                g.selectAll('*').remove();

                // Add arrow marker definitions
                const defs = this.svg.select('defs').empty() ? this.svg.append('defs') : this.svg.select('defs');
                
                // Clear existing markers
                defs.selectAll('marker').remove();
                
                // Create arrow marker
                defs.append('marker')
                    .attr('id', 'arrow')
                    .attr('viewBox', '0 -5 10 10')
                    .attr('refX', 15)  // Position arrow at end of line
                    .attr('refY', 0)
                    .attr('markerWidth', 6)
                    .attr('markerHeight', 6)
                    .attr('orient', 'auto')
                    .append('path')
                    .attr('d', 'M0,-5L10,0L0,5')
                    .attr('fill', '#f97316')
                    .attr('stroke', '#f97316')
                    .attr('stroke-width', 1);

                // Color scale for different node labels
                const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

                // Check if we should use coordinate layout
                const useCoordinates = this.currentLayout === 'coordinates' && this.hasCoordinates(data.nodes);
                
                // Update layout status
                this.updateLayoutStatus(useCoordinates, data.nodes.length);

                // Prepare node positions for coordinate layout
                if (useCoordinates) {
                    this.setupCoordinateLayout(data.nodes, width, height);
                }

                // Create simulation only for force layouts
                if (!useCoordinates) {
                    this.simulation = d3.forceSimulation(data.nodes)
                        .force('link', d3.forceLink(data.links).id(d => d.id).distance(100))
                        .force('charge', d3.forceManyBody().strength(-300))
                        .force('center', d3.forceCenter(width / 2, height / 2));
                } else {
                    // For coordinate layout, stop any existing simulation
                    if (this.simulation) {
                        this.simulation.stop();
                    }
                }

                // Create links
                const link = g.selectAll('.link')
                    .data(data.links)
                    .enter().append('line')
                    .attr('class', 'link')
                    .attr('marker-end', 'url(#arrow)');  // Add arrow marker

                // Add relationship labels
                const linkLabels = g.selectAll('.link-label')
                    .data(data.links)
                    .enter().append('text')
                    .attr('class', 'link-label')
                    .text(d => d.type || 'unknown')
                    .style('font-size', '10px')
                    .style('fill', '#666')
                    .style('text-anchor', 'middle')
                    .style('pointer-events', 'none')
                    .style('display', this.showLabels ? 'block' : 'none');

                // Create nodes
                const node = g.selectAll('.node')
                    .data(data.nodes)
                    .enter().append('circle')
                    .attr('class', 'node')
                    .attr('r', 8)
                    .attr('fill', d => {
                        // Use color from data if available, otherwise default to gray
                        if (d.color) {
                            return d.color;
                        }
                        // Fallback to gray for nodes without color data
                        return '#999999';
                    })
                    .attr('stroke', '#fff')
                    .call(d3.drag()
                        .on('start', this.dragstarted.bind(this))
                        .on('drag', this.dragged.bind(this))
                        .on('end', this.dragended.bind(this)));

                // Add node labels
                const labels = g.selectAll('.node-label')
                    .data(data.nodes)
                    .enter().append('text')
                    .attr('class', 'node-label')
                    .text(d => d.name)
                    .style('display', this.showLabels ? 'block' : 'none');

                // Node click handler
                node.on('click', (event, d) => {
                    this.selectNode(d);
                });

                if (useCoordinates) {
                    // Position nodes and links immediately using coordinates
                    this.updateCoordinatePositions(link, node, labels, linkLabels);
                } else {
                    // Update positions on simulation tick for force layouts
                    this.simulation.on('tick', () => {
                        // Update links with proper positioning to avoid overlap with nodes
                        link
                            .attr('x1', d => {
                                const dx = d.target.x - d.source.x;
                                const dy = d.target.y - d.source.y;
                                const length = Math.sqrt(dx * dx + dy * dy);
                                const nodeRadius = 8;
                                return length > 0 ? d.source.x + (dx * nodeRadius / length) : d.source.x;
                            })
                            .attr('y1', d => {
                                const dx = d.target.x - d.source.x;
                                const dy = d.target.y - d.source.y;
                                const length = Math.sqrt(dx * dx + dy * dy);
                                const nodeRadius = 8;
                                return length > 0 ? d.source.y + (dy * nodeRadius / length) : d.source.y;
                            })
                            .attr('x2', d => {
                                const dx = d.target.x - d.source.x;
                                const dy = d.target.y - d.source.y;
                                const length = Math.sqrt(dx * dx + dy * dy);
                                const nodeRadius = 8;
                                return length > 0 ? d.target.x - (dx * nodeRadius / length) : d.target.x;
                            })
                            .attr('y2', d => {
                                const dx = d.target.x - d.source.x;
                                const dy = d.target.y - d.source.y;
                                const length = Math.sqrt(dx * dx + dy * dy);
                                const nodeRadius = 8;
                                return length > 0 ? d.target.y - (dy * nodeRadius / length) : d.target.y;
                            });

                        // Position relationship labels in the middle of links
                        linkLabels
                            .attr('x', d => (d.source.x + d.target.x) / 2)
                            .attr('y', d => (d.source.y + d.target.y) / 2);

                        node
                            .attr('cx', d => d.x)
                            .attr('cy', d => d.y);

                        labels
                            .attr('x', d => d.x)
                            .attr('y', d => d.y + 20);
                    });
                }
            }

            hasCoordinates(nodes) {
                // Check if nodes have coordinate properties
                // Look for common coordinate property names
                const coordinateProps = ['x', 'y', 'X', 'Y', 'coord_x', 'coord_y', 'position_x', 'position_y'];
                
                return nodes.some(node => {
                    const props = node.properties || {};
                    const hasX = coordinateProps.some(prop => props.hasOwnProperty(prop) && 
                        typeof props[prop] === 'number' && !isNaN(props[prop]));
                    const hasY = coordinateProps.some(prop => prop.includes('y') || prop.includes('Y')) && 
                        coordinateProps.some(prop => props.hasOwnProperty(prop) && 
                        typeof props[prop] === 'number' && !isNaN(props[prop]));
                    return hasX && hasY;
                });
            }

            setupCoordinateLayout(nodes, width, height) {
                // Find coordinate properties and scale them to fit the viewport
                const coordinateProps = ['x', 'y', 'X', 'Y', 'coord_x', 'coord_y', 'position_x', 'position_y'];
                
                // Extract coordinate values
                const coordinates = nodes.map(node => {
                    const props = node.properties || {};
                    let x = null, y = null;
                    
                    // Find X coordinate
                    for (let prop of coordinateProps) {
                        if ((prop.includes('x') || prop.includes('X')) && 
                            props.hasOwnProperty(prop) && 
                            typeof props[prop] === 'number' && !isNaN(props[prop])) {
                            x = props[prop];
                            break;
                        }
                    }
                    
                    // Find Y coordinate
                    for (let prop of coordinateProps) {
                        if ((prop.includes('y') || prop.includes('Y')) && 
                            props.hasOwnProperty(prop) && 
                            typeof props[prop] === 'number' && !isNaN(props[prop])) {
                            y = props[prop];
                            break;
                        }
                    }
                    
                    return { x, y };
                }).filter(coord => coord.x !== null && coord.y !== null);

                if (coordinates.length === 0) return;

                // Calculate bounds
                const xExtent = d3.extent(coordinates, d => d.x);
                const yExtent = d3.extent(coordinates, d => d.y);

                // Create scales with padding
                const padding = 50;
                const xScale = d3.scaleLinear()
                    .domain(xExtent)
                    .range([padding, width - padding]);
                
                const yScale = d3.scaleLinear()
                    .domain(yExtent)
                    .range([height - padding, padding]); // Invert Y for SVG coordinate system

                // Apply scaled coordinates to nodes
                nodes.forEach(node => {
                    const props = node.properties || {};
                    let originalX = null, originalY = null;
                    
                    // Find original coordinates
                    for (let prop of coordinateProps) {
                        if ((prop.includes('x') || prop.includes('X')) && 
                            props.hasOwnProperty(prop) && 
                            typeof props[prop] === 'number' && !isNaN(props[prop])) {
                            originalX = props[prop];
                            break;
                        }
                    }
                    
                    for (let prop of coordinateProps) {
                        if ((prop.includes('y') || prop.includes('Y')) && 
                            props.hasOwnProperty(prop) && 
                            typeof props[prop] === 'number' && !isNaN(props[prop])) {
                            originalY = props[prop];
                            break;
                        }
                    }
                    
                    if (originalX !== null && originalY !== null) {
                        node.x = xScale(originalX);
                        node.y = yScale(originalY);
                        node.fx = node.x; // Fix position
                        node.fy = node.y;
                    }
                });
            }

            updateCoordinatePositions(link, node, labels, linkLabels) {
                // Position nodes using their calculated coordinates
                node
                    .attr('cx', d => d.x || 0)
                    .attr('cy', d => d.y || 0);

                labels
                    .attr('x', d => d.x || 0)
                    .attr('y', d => (d.y || 0) + 20);

                // Position links - get the actual data arrays
                const nodeData = node.data();
                const linkData = link.data();

                link
                    .attr('x1', d => {
                        const sourceNode = nodeData.find(n => n.id === d.source);
                        const targetNode = nodeData.find(n => n.id === d.target);
                        if (!sourceNode || !targetNode) return 0;
                        
                        const dx = targetNode.x - sourceNode.x;
                        const dy = targetNode.y - sourceNode.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const nodeRadius = 8;
                        return length > 0 ? sourceNode.x + (dx * nodeRadius / length) : sourceNode.x;
                    })
                    .attr('y1', d => {
                        const sourceNode = nodeData.find(n => n.id === d.source);
                        const targetNode = nodeData.find(n => n.id === d.target);
                        if (!sourceNode || !targetNode) return 0;
                        
                        const dx = targetNode.x - sourceNode.x;
                        const dy = targetNode.y - sourceNode.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const nodeRadius = 8;
                        return length > 0 ? sourceNode.y + (dy * nodeRadius / length) : sourceNode.y;
                    })
                    .attr('x2', d => {
                        const sourceNode = nodeData.find(n => n.id === d.source);
                        const targetNode = nodeData.find(n => n.id === d.target);
                        if (!sourceNode || !targetNode) return 0;
                        
                        const dx = targetNode.x - sourceNode.x;
                        const dy = targetNode.y - sourceNode.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const nodeRadius = 8;
                        return length > 0 ? targetNode.x - (dx * nodeRadius / length) : targetNode.x;
                    })
                    .attr('y2', d => {
                        const sourceNode = nodeData.find(n => n.id === d.source);
                        const targetNode = nodeData.find(n => n.id === d.target);
                        if (!sourceNode || !targetNode) return 0;
                        
                        const dx = targetNode.x - sourceNode.x;
                        const dy = targetNode.y - sourceNode.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const nodeRadius = 8;
                        return length > 0 ? targetNode.y - (dy * nodeRadius / length) : targetNode.y;
                    });

                // Position relationship labels in the middle of links
                if (linkLabels) {
                    linkLabels
                        .attr('x', d => {
                            const sourceNode = nodeData.find(n => n.id === d.source);
                            const targetNode = nodeData.find(n => n.id === d.target);
                            const sourceX = sourceNode ? sourceNode.x : 0;
                            const targetX = targetNode ? targetNode.x : 0;
                            return (sourceX + targetX) / 2;
                        })
                        .attr('y', d => {
                            const sourceNode = nodeData.find(n => n.id === d.source);
                            const targetNode = nodeData.find(n => n.id === d.target);
                            const sourceY = sourceNode ? sourceNode.y : 0;
                            const targetY = targetNode ? targetNode.y : 0;
                            return (sourceY + targetY) / 2;
                        });
                }
            }

            updateLayoutStatus(useCoordinates, nodeCount) {
                const statusDiv = document.getElementById('layout-status');
                if (this.currentLayout === 'coordinates') {
                    if (useCoordinates) {
                        statusDiv.innerHTML = `📍 Using node coordinates for ${nodeCount} nodes`;
                        statusDiv.style.color = '#28a745';
                    } else {
                        statusDiv.innerHTML = '⚠️ No coordinate data found, using force layout';
                        statusDiv.style.color = '#ffc107';
                    }
                } else {
                    statusDiv.innerHTML = '';
                }
            }

            selectNode(node) {
                this.selectedNode = node;
                this.showNodeDetails(node);
                this.loadNodeRelationships(node.id);

                // Highlight selected node
                this.svg.selectAll('.node')
                    .attr('stroke-width', d => d.id === node.id ? 4 : 2)
                    .attr('stroke', d => d.id === node.id ? '#ff6b6b' : '#fff');
            }

            showNodeDetails(node) {
                const section = document.getElementById('node-details-section');
                const details = document.getElementById('selected-node-details');
                
                details.innerHTML = `
                    <div class="node-details">
                        <h4>ID: ${node.id}</h4>
                        <p><strong>Labels:</strong> ${node.labels.join(', ')}</p>
                        <h5>Properties:</h5>
                        <ul class="property-list">
                            ${Object.entries(node.properties).map(([key, value]) => `
                                <li class="property-item">
                                    <span class="property-key">${key}:</span>
                                    <span class="property-value">${value}</span>
                                </li>
                            `).join('')}
                        </ul>
                    </div>
                `;
                
                section.style.display = 'block';
            }

            async loadNodeRelationships(nodeId) {
                try {
                    const response = await fetch(`/api/node/${nodeId}/relationships`);
                    const relationships = await response.json();
                    this.showRelationshipDetails(relationships);
                } catch (error) {
                    console.error('Error loading node relationships:', error);
                }
            }

            showRelationshipDetails(relationships) {
                const section = document.getElementById('relationship-details-section');
                const details = document.getElementById('selected-relationship-details');
                
                if (relationships.length === 0) {
                    details.innerHTML = '<p>No relationships found</p>';
                    section.style.display = 'block';
                    return;
                }

                details.innerHTML = relationships.map(rel => `
                    <div class="relationship-details">
                        <h5>${rel.relationship.type}</h5>
                        <p><strong>From:</strong> ${rel.source.properties.name || rel.source.id} (${rel.source.labels.join(', ')})</p>
                        <p><strong>To:</strong> ${rel.target.properties.name || rel.target.id} (${rel.target.labels.join(', ')})</p>
                        ${Object.keys(rel.relationship.properties).length > 0 ? `
                            <h6>Properties:</h6>
                            <ul class="property-list">
                                ${Object.entries(rel.relationship.properties).map(([key, value]) => `
                                    <li class="property-item">
                                        <span class="property-key">${key}:</span>
                                        <span class="property-value">${value}</span>
                                    </li>
                                `).join('')}
                            </ul>
                        ` : ''}
                    </div>
                `).join('');
                
                section.style.display = 'block';
            }

            setupEventListeners() {
                // Refresh button - complete reset
                document.getElementById('refresh-btn').addEventListener('click', () => {
                    this.refreshAndReset();
                });

                // Reset zoom button
                document.getElementById('reset-zoom-btn').addEventListener('click', () => {
                    this.svg.transition().duration(750).call(
                        d3.zoom().transform,
                        d3.zoomIdentity
                    );
                });

                // Toggle labels button
                document.getElementById('toggle-labels-btn').addEventListener('click', () => {
                    this.showLabels = !this.showLabels;
                    this.svg.selectAll('.node-label')
                        .style('display', this.showLabels ? 'block' : 'none');
                    this.svg.selectAll('.link-label')
                        .style('display', this.showLabels ? 'block' : 'none');
                });

                // Clear filters button
                document.getElementById('clear-filters-btn').addEventListener('click', () => {
                    this.clearFilters();
                });

                // Layout selector
                document.getElementById('layout-select').addEventListener('change', (e) => {
                    this.currentLayout = e.target.value;
                    this.applyLayout();
                });

                // Find intersections button
                document.getElementById('find-intersections-btn').addEventListener('click', () => {
                    this.findIntersections();
                });
            }

            setupSearch() {
                const searchInput = document.getElementById('search-input');
                const searchResults = document.getElementById('search-results');
                let searchTimeout;

                searchInput.addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    const query = e.target.value.trim();

                    if (query.length < 2) {
                        searchResults.innerHTML = '';
                        return;
                    }

                    searchTimeout = setTimeout(async () => {
                        try {
                            const response = await fetch(`/api/search?q=${encodeURIComponent(query)}`);
                            const results = await response.json();
                            this.renderSearchResults(results);
                        } catch (error) {
                            console.error('Error searching:', error);
                        }
                    }, 300);
                });
            }

            renderSearchResults(results) {
                const searchResults = document.getElementById('search-results');
                
                if (results.length === 0) {
                    searchResults.innerHTML = '<p style="color: #999; padding: 0.5rem;">No results found</p>';
                    return;
                }

                searchResults.innerHTML = results.map(node => `
                    <div class="search-result" style="padding: 0.5rem; border: 1px solid #e2e8f0; margin-bottom: 0.5rem; border-radius: 4px; cursor: pointer;" data-node-id="${node.id}">
                        <strong>${node.properties.name || `Node ${node.id}`}</strong><br>
                        <small style="color: #666;">${node.labels.join(', ')}</small>
                    </div>
                `).join('');

                // Add click listeners to search results
                searchResults.querySelectorAll('.search-result').forEach(result => {
                    result.addEventListener('click', () => {
                        const nodeId = parseInt(result.dataset.nodeId);
                        // Find and select the node if it's in the current graph
                        const node = this.svg.selectAll('.node').data().find(n => n.id === nodeId);
                        if (node) {
                            this.selectNode(node);
                        }
                    });
                });
            }

            applyLayout() {
                if (this.currentLayout === 'coordinates') {
                    // Reload graph data to apply coordinate layout
                    this.loadGraphData();
                    return;
                }

                if (!this.simulation) return;

                const width = this.svg.attr('width');
                const height = this.svg.attr('height');

                this.simulation.stop();

                switch (this.currentLayout) {
                    case 'circle':
                        this.simulation.force('center', null);
                        break;
                    case 'grid':
                        this.simulation.force('center', null);
                        break;
                    default:
                        this.simulation.force('center', d3.forceCenter(width / 2, height / 2));
                }

                this.simulation.alpha(1).restart();
            }

            dragstarted(event, d) {
                if (this.simulation && !event.active) {
                    this.simulation.alphaTarget(0.3).restart();
                }
                d.fx = d.x;
                d.fy = d.y;
            }

            dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            dragended(event, d) {
                if (this.simulation && !event.active) {
                    this.simulation.alphaTarget(0);
                }
                // For coordinate layout, keep the position fixed
                if (this.currentLayout === 'coordinates') {
                    d.fx = event.x;
                    d.fy = event.y;
                } else {
                    d.fx = null;
                    d.fy = null;
                }
            }
        }

        // Initialize the explorer when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing Neo4jExplorer...');
            try {
                // Make explorer globally accessible
                window.explorer = new Neo4jExplorer();
                console.log('Neo4jExplorer created successfully');
            } catch (error) {
                console.error('Failed to create Neo4jExplorer:', error);
                
                // Show error to user
                const container = document.querySelector('.container');
                if (container) {
                    container.innerHTML = `
                        <div style="background: #f8d7da; color: #721c24; padding: 2rem; border-radius: 8px; margin: 2rem;">
                            <h3>Explorer Failed to Start</h3>
                            <p>Error: ${error.message}</p>
                            <p>Please check the console for more details and refresh the page to try again.</p>
                        </div>
                    `;
                }
            }
        });
    </script>
</body>
</html>
